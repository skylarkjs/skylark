{"version":3,"sources":["finder.js"],"names":["define","skylark","langx","browser","noder","velm","ancestor","node","selector","root","rootIsSelector","isString","parentNode","matches","ancestors","ret","push","local","filter","byId","id","doc","getElementById","children","childNodes","i","length","nodeType","closest","descendants","elm","slice","call","querySelectorAll","matchError","query","descendant","querySelector","nodes","find","document","body","findAll","firstChild","first","nextSibling","lastChild","last","previousSibling","nativeMatchesSelector","replace","match","isArrayLike","inArray","isPlainObject","check","adjacent","nextSiblings","parent","previousSiblings","siblings","Array","prototype","matchesSelector","parser","rawMatch","separator","combinator","combinatorChildren","tagName","className","attributeKey","attributeOperator","attributeQuote","attributeValue","pseudoMarker","pseudoClass","pseudoQuote","pseudoClassQuotedValue","pseudoClassValue","separatorIndex","parsed","expressions","combinatorIndex","currentSeparator","reversed","reverseCombinator","tag","currentParsed","reUnescape","classList","classes","value","regexp","RegExp","escapeRegExp","pseudos","key","type","test","indexOf","attributes","operator","cache","reverseCache","parse","expression","isReversed","Slick","currentCache","raw","reverse","this","exp","parts","j","cexp","from","to","string","apply","parseSelector","checkbox","checked","contains","idx","text","$","disabled","enabled","eq","focus","activeElement","href","tabindex","gt","has","sel","hidden","lt","not","radio","selected","visible","offsetWidth","forEach","item","isArrayFilter","divide","cond","nativeSelector","customPseudos","JSON","stringify","part","undefined","toUpperCase","arrayFilte","cls","pseudo","nodeName","getAttribute","hasAttribute","currentExpression","simpleExpCounter","filterSingle","matchs","Error","uniq","concat","combine","bit","node1","op","prev","next","divided","single","currentBit","founds","found","currentItems","map","finder","mixin"],"mappings":"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","file":"../finder.js","sourcesContent":["define([\n    \"./skylark\",\n    \"./langx\",\n    \"./browser\",\n    \"./noder\"\n], function(skylark, langx, browser, noder, velm) {\n    var local = {},\n        filter = Array.prototype.filter,\n        slice = Array.prototype.slice,\n        nativeMatchesSelector = browser.matchesSelector;\n\n    /*\n    ---\n    name: Slick.Parser\n    description: Standalone CSS3 Selector parser\n    provides: Slick.Parser\n    ...\n    */\n    ;\n    (function() {\n\n        var parsed,\n            separatorIndex,\n            combinatorIndex,\n            reversed,\n            cache = {},\n            reverseCache = {},\n            reUnescape = /\\\\/g;\n\n        var parse = function(expression, isReversed) {\n            if (expression == null) return null;\n            if (expression.Slick === true) return expression;\n            expression = ('' + expression).replace(/^\\s+|\\s+$/g, '');\n            reversed = !!isReversed;\n            var currentCache = (reversed) ? reverseCache : cache;\n            if (currentCache[expression]) return currentCache[expression];\n            parsed = {\n                Slick: true,\n                expressions: [],\n                raw: expression,\n                reverse: function() {\n                    return parse(this.raw, true);\n                }\n            };\n            separatorIndex = -1;\n            while (expression != (expression = expression.replace(regexp, parser)));\n            parsed.length = parsed.expressions.length;\n            return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;\n        };\n\n        var reverseCombinator = function(combinator) {\n            if (combinator === '!') return ' ';\n            else if (combinator === ' ') return '!';\n            else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');\n            else return '!' + combinator;\n        };\n\n        var reverse = function(expression) {\n            var expressions = expression.expressions;\n            for (var i = 0; i < expressions.length; i++) {\n                var exp = expressions[i];\n                var last = {\n                    parts: [],\n                    tag: '*',\n                    combinator: reverseCombinator(exp[0].combinator)\n                };\n\n                for (var j = 0; j < exp.length; j++) {\n                    var cexp = exp[j];\n                    if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';\n                    cexp.combinator = cexp.reverseCombinator;\n                    delete cexp.reverseCombinator;\n                }\n\n                exp.reverse().push(last);\n            }\n            return expression;\n        };\n\n        var escapeRegExp = (function() {\n            // Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License\n            var from = /(?=[\\-\\[\\]{}()*+?.\\\\\\^$|,#\\s])/g,\n                to = '\\\\';\n            return function(string) {\n                return string.replace(from, to)\n            }\n        }())\n\n        var regexp = new RegExp(\n            \"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\"\n            .replace(/<combinator>/, '[' + escapeRegExp(\">+~`!@$%^&={}\\\\;</\") + ']')\n            .replace(/<unicode>/g, '(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\n            .replace(/<unicode1>/g, '(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\n        );\n\n        function parser(\n            rawMatch,\n\n            separator,\n            combinator,\n            combinatorChildren,\n\n            tagName,\n            id,\n            className,\n\n            attributeKey,\n            attributeOperator,\n            attributeQuote,\n            attributeValue,\n\n            pseudoMarker,\n            pseudoClass,\n            pseudoQuote,\n            pseudoClassQuotedValue,\n            pseudoClassValue\n        ) {\n            if (separator || separatorIndex === -1) {\n                parsed.expressions[++separatorIndex] = [];\n                combinatorIndex = -1;\n                if (separator) return '';\n            }\n\n            if (combinator || combinatorChildren || combinatorIndex === -1) {\n                combinator = combinator || ' ';\n                var currentSeparator = parsed.expressions[separatorIndex];\n                if (reversed && currentSeparator[combinatorIndex])\n                    currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);\n                currentSeparator[++combinatorIndex] = {\n                    combinator: combinator,\n                    tag: '*'\n                };\n            }\n\n            var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];\n\n            if (tagName) {\n                currentParsed.tag = tagName.replace(reUnescape, '');\n\n            } else if (id) {\n                currentParsed.id = id.replace(reUnescape, '');\n\n            } else if (className) {\n                className = className.replace(reUnescape, '');\n\n                if (!currentParsed.classList) currentParsed.classList = [];\n                if (!currentParsed.classes) currentParsed.classes = [];\n                currentParsed.classList.push(className);\n                currentParsed.classes.push({\n                    value: className,\n                    regexp: new RegExp('(^|\\\\s)' + escapeRegExp(className) + '(\\\\s|$)')\n                });\n\n            } else if (pseudoClass) {\n                pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;\n                pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;\n\n                if (!currentParsed.pseudos) currentParsed.pseudos = [];\n                currentParsed.pseudos.push({\n                    key: pseudoClass.replace(reUnescape, ''),\n                    value: pseudoClassValue,\n                    type: pseudoMarker.length == 1 ? 'class' : 'element'\n                });\n\n            } else if (attributeKey) {\n                attributeKey = attributeKey.replace(reUnescape, '');\n                attributeValue = (attributeValue || '').replace(reUnescape, '');\n\n                var test, regexp;\n\n                switch (attributeOperator) {\n                    case '^=':\n                        regexp = new RegExp('^' + escapeRegExp(attributeValue));\n                        break;\n                    case '$=':\n                        regexp = new RegExp(escapeRegExp(attributeValue) + '$');\n                        break;\n                    case '~=':\n                        regexp = new RegExp('(^|\\\\s)' + escapeRegExp(attributeValue) + '(\\\\s|$)');\n                        break;\n                    case '|=':\n                        regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');\n                        break;\n                    case '=':\n                        test = function(value) {\n                            return attributeValue == value;\n                        };\n                        break;\n                    case '*=':\n                        test = function(value) {\n                            return value && value.indexOf(attributeValue) > -1;\n                        };\n                        break;\n                    case '!=':\n                        test = function(value) {\n                            return attributeValue != value;\n                        };\n                        break;\n                    default:\n                        test = function(value) {\n                            return !!value;\n                        };\n                }\n\n                if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function() {\n                    return false;\n                };\n\n                if (!test) test = function(value) {\n                    return value && regexp.test(value);\n                };\n\n                if (!currentParsed.attributes) currentParsed.attributes = [];\n                currentParsed.attributes.push({\n                    key: attributeKey,\n                    operator: attributeOperator,\n                    value: attributeValue,\n                    test: test\n                });\n\n            }\n\n            return '';\n        };\n\n        // Slick NS\n\n        var Slick = (this.Slick || {});\n\n        Slick.parse = function(expression) {\n            return parse(expression);\n        };\n\n        Slick.escapeRegExp = escapeRegExp;\n\n        if (!this.Slick) this.Slick = Slick;\n\n    }).apply(local);\n\n\n    var simpleClassSelectorRE = /^\\.([\\w-]*)$/,\n        simpleIdSelectorRE = /^#([\\w-]*)$/,\n        slice = Array.prototype.slice;\n\n\n    local.parseSelector = local.Slick.parse;\n\n\n    local.pseudos = {\n        // custom pseudos\n        'checkbox': function(elm){\n            return elm.type === \"checkbox\";\n        },\n        'checked': function(elm) {\n            return !!elm.checked;\n        },\n\n        'contains': function(elm, idx, nodes, text) {\n            if ($(this).text().indexOf(text) > -1) return this\n        },\n\n        'disabled': function(elm) {\n            return !!elm.disabled;\n        },\n\n        'enabled': function(elm) {\n            return !elm.disabled;\n        },\n\n        'eq': function(elm, idx, nodes, value) {\n            return (idx == value);\n        },\n\n        'focus': function(elm) {\n            return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);\n        },\n\n        'first': function(elm, idx) {\n            return (idx === 0);\n        },\n\n        'gt': function(elm, idx, nodes, value) {\n            return (idx > value);\n        },\n\n        'has': function(elm, idx, nodes, sel) {\n            return local.querySelector(elm, sel).length > 0;\n        },\n\n\n        'hidden': function(elm) {\n            return !local.pseudos[\"visible\"](elm);\n        },\n\n        'last': function(elm, idx, nodes) {\n            return (idx === nodes.length - 1);\n        },\n\n        'lt': function(elm, idx, nodes, value) {\n            return (idx < value);\n        },\n\n        'not': function(elm, idx, nodes, sel) {\n            return local.match(elm, sel);\n        },\n\n        'parent': function(elm) {\n            return !!elm.parentNode;\n        },\n\n        'radio': function(elm){\n            return elm.type === \"radio\";\n        },\n\n        'selected': function(elm) {\n            return !!elm.selected;\n        },\n\n        'text': function(elm){\n            return elm.type === \"text\";\n        },\n\n        'visible': function(elm) {\n            return elm.offsetWidth && elm.offsetWidth\n        }\n    };\n\n    [\"first\",\"eq\",\"last\"].forEach(function(item){\n        local.pseudos[item].isArrayFilter = true;\n    });\n\n    local.divide = function(cond) {\n        var nativeSelector = \"\",\n            customPseudos = [],\n            tag,\n            id,\n            classes,\n            attributes,\n            pseudos;\n\n\n        if (id = cond.id) {\n            nativeSelector += (\"#\" + id);\n        }\n        if (classes = cond.classes) {\n            for (var i = classes.length; i--;) {\n                nativeSelector += (\".\" + classes[i].value);\n            }\n        }\n        if (attributes = cond.attributes) {\n            for (var i = 0; i < attributes.length; i++) {\n                if (attributes[i].operator) {\n                    nativeSelector += (\"[\" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value)  +\"]\");\n                } else {\n                    nativeSelector += (\"[\" + attributes[i].key + \"]\");\n                }\n            }\n        }\n        if (pseudos = cond.pseudos) {\n            for (i = pseudos.length; i--;) {\n                part = pseudos[i];\n                if (this.pseudos[part.key]) {\n                    customPseudos.push(part);\n                } else {\n                    if (part.value !== undefined) {\n                        nativeSelector += (\":\" + part.key + \"(\" + JSON.stringify(part))\n                    }\n                }\n            }\n        }\n\n        if (tag = cond.tag) {\n            nativeSelector = tag.toUpperCase() + nativeSelector;\n        }\n\n        if (!nativeSelector) {\n            nativeSelector = \"*\";\n        }\n\n        return {\n            nativeSelector: nativeSelector,\n            customPseudos: customPseudos\n        }\n\n    };\n\n    local.check = function(node, cond, idx, nodes,arrayFilte) {\n        var tag,\n            id,\n            classes,\n            attributes,\n            pseudos,\n\n            i, part, cls, pseudo;\n\n        if (!arrayFilte) {\n            if (tag = cond.tag) {\n                var nodeName = node.nodeName.toUpperCase();\n                if (tag == '*') {\n                    if (nodeName < '@') return false; // Fix for comment nodes and closed nodes\n                } else {\n                    if (nodeName != (tag || \"\").toUpperCase()) return false;\n                }\n            }\n\n            if (id = cond.id) {\n                if (node.getAttribute('id') != id) {\n                    return false;\n                }\n            }\n\n\n            if (classes = cond.classes) {\n                for (i = classes.length; i--;) {\n                    cls = node.getAttribute('class');\n                    if (!(cls && classes[i].regexp.test(cls))) return false;\n                }\n            }\n\n            if (attributes) {\n                for (i = attributes.length; i--;) {\n                    part = attributes[i];\n                    if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;\n                }\n\n            }\n\n        }\n        if (pseudos = cond.pseudos) {\n            for (i = pseudos.length; i--;) {\n                part = pseudos[i];\n                if (pseudo = this.pseudos[part.key]) {\n                    if ((arrayFilte && pseudo.isArrayFilter) || (!arrayFilte && !pseudo.isArrayFilter)) {\n                        if (!pseudo(node, idx, nodes, part.value)) {\n                            return false;\n                        }\n                    }\n                } else {\n                    if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    local.match = function(node, selector) {\n\n        var parsed ;\n\n        if (langx.isString(selector)) {\n            parsed = local.Slick.parse(selector);\n        } else {\n            parsed = selector;            \n        }\n        \n        if (!parsed) {\n            return true;\n        }\n\n        // simple (single) selectors\n        var expressions = parsed.expressions,\n            simpleExpCounter = 0,\n            i,\n            currentExpression;\n        for (i = 0;\n            (currentExpression = expressions[i]); i++) {\n            if (currentExpression.length == 1) {\n                var exp = currentExpression[0];\n                if (this.check(node,exp)) {\n                    return true;\n                }\n                simpleExpCounter++;\n            }\n        }\n\n        if (simpleExpCounter == parsed.length) {\n            return false;\n        }\n\n        var nodes = this.query(document, parsed),\n            item;\n        for (i = 0; item = nodes[i++];) {\n            if (item === node) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n\n    local.filterSingle = function(nodes, exp){\n        var matchs = filter.call(nodes, function(node, idx) {\n            return local.check(node, exp, idx, nodes,false);\n        });    \n\n        matchs = filter.call(matchs, function(node, idx) {\n            return local.check(node, exp, idx, matchs,true);\n        }); \n        return matchs;\n    };\n\n    local.filter = function(nodes, selector) {\n        var parsed;\n\n        if (langx.isString(selector)) {\n            parsed = local.Slick.parse(selector);\n        } else {\n            return local.filterSingle(nodes,selector);           \n        }\n\n        // simple (single) selectors\n        var expressions = parsed.expressions,\n            i,\n            currentExpression,\n            ret = [];\n        for (i = 0;\n            (currentExpression = expressions[i]); i++) {\n            if (currentExpression.length == 1) {\n                var exp = currentExpression[0];\n\n                var matchs = local.filterSingle(nodes,exp);  \n\n                ret = langx.uniq(ret.concat(matchs));\n            } else {\n                throw new Error(\"not supported selector:\" + selector);\n            }\n        }\n\n        return ret;\n \n    };    \n\n    local.combine = function(elm, bit) {\n        var op = bit.combinator,\n            cond = bit,\n            node1,\n            nodes = [];\n\n        switch (op) {\n            case '>': // direct children\n                nodes = children(elm, cond);\n                break;\n            case '+': // next sibling\n                node1 = nextSibling(elm, cond, true);\n                if (node1) {\n                    nodes.push(node1);\n                }\n                break;\n            case '^': // first child\n                node1 = firstChild(elm, cond, true);\n                if (node1) {\n                    nodes.push(node1);\n                }\n                break;\n            case '~': // next siblings\n                nodes = nextSiblings(elm, cond);\n                break;\n            case '++': // next sibling and previous sibling\n                var prev = previousSibling(elm, cond, true),\n                    next = nextSibling(elm, cond, true);\n                if (prev) {\n                    nodes.push(prev);\n                }\n                if (next) {\n                    nodes.push(next);\n                }\n                break;\n            case '~~': // next siblings and previous siblings\n                nodes = siblings(elm, cond);\n                break;\n            case '!': // all parent nodes up to document\n                nodes = ancestors(elm, cond);\n                break;\n            case '!>': // direct parent (one level)\n                node1 = parent(elm, cond);\n                if (node1) {\n                    nodes.push(node1);\n                }\n                break;\n            case '!+': // previous sibling\n                nodes = previousSibling(elm, cond, true);\n                break;\n            case '!^': // last child\n                node1 = lastChild(elm, cond, true);\n                if (node1) {\n                    nodes.push(node1);\n                }\n                break;\n            case '!~': // previous siblings\n                nodes = previousSiblings(elm, cond);\n                break;\n            default:\n                var divided = this.divide(bit);\n                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));\n                if (divided.customPseudos) {\n                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {\n                        nodes = filter.call(nodes, function(item, idx) {\n                            return local.check(item, {\n                                pseudos: [divided.customPseudos[i]]\n                            }, idx, nodes,false)\n                        });\n\n                        nodes = filter.call(nodes, function(item, idx) {\n                            return local.check(item, {\n                                pseudos: [divided.customPseudos[i]]\n                            }, idx, nodes,true)\n                        });                        \n                    }\n                }\n                break;\n\n        }\n        return nodes;\n    }\n\n    local.query = function(node, selector, single) {\n\n\n        var parsed = this.Slick.parse(selector);\n\n        var\n            founds = [],\n            currentExpression, currentBit,\n            expressions = parsed.expressions;\n\n        for (var i = 0;\n            (currentExpression = expressions[i]); i++) {\n            var currentItems = [node],\n                found;\n            for (var j = 0;\n                (currentBit = currentExpression[j]); j++) {\n                found = langx.map(currentItems, function(item, i) {\n                    return local.combine(item, currentBit)\n                });\n                if (found) {\n                    currentItems = found;\n                }\n            }\n            if (found) {\n                founds = founds.concat(found);\n            }\n        }\n\n        return founds;\n    }\n\n\n    function ancestor(node, selector, root) {\n        var rootIsSelector = root && langx.isString(root);\n        while (node = node.parentNode) {\n            if (matches(node, selector)) {\n                return node;\n            }\n            if (root) {\n                if (rootIsSelector) {\n                    if (matches(node,root)) {\n                        break;\n                    }\n                } else if (node == root) {\n                    break;\n                }\n            } \n        }\n        return null;\n    }\n\n    function ancestors(node, selector,root) {\n        var ret = [],\n            rootIsSelector = root && langx.isString(root);\n        while (node = node.parentNode) {\n                ret.push(node);\n            if (root) {\n                if (rootIsSelector) {\n                    if (matches(node,root)) {\n                        break;\n                    }\n                } else if (node == root) {\n                    break;\n                }\n            } \n\n        }\n\n        if (selector) {\n            ret = local.filter(ret,selector);\n        }\n        return ret;\n    }\n\n    function byId(id, doc) {\n        doc = doc || noder.doc();\n        return doc.getElementById(id);\n    }\n\n    function children(node, selector) {\n        var childNodes = node.childNodes,\n            ret = [];\n        for (var i = 0; i < childNodes.length; i++) {\n            var node = childNodes[i];\n            if (node.nodeType == 1) {\n                ret.push(node);\n            }\n        }\n        if (selector) {\n            ret = local.filter(ret,selector);\n        }\n        return ret;\n    }\n\n    function closest(node, selector) {\n        while (node && !(matches(node, selector))) {\n            node = node.parentNode;\n        }\n\n        return node;\n    }\n\n    function descendants(elm, selector) {\n        // Selector\n        try {\n            return slice.call(elm.querySelectorAll(selector));\n        } catch (matchError) {\n            //console.log(matchError);\n        }\n        return local.query(elm, selector);\n    }\n\n    function descendant(elm, selector) {\n        // Selector\n        try {\n            return elm.querySelector(selector);\n        } catch (matchError) {\n            //console.log(matchError);\n        }\n        var nodes = local.query(elm, selector);\n        if (nodes.length > 0) {\n            return nodes[0];\n        } else {\n            return null;\n        }\n    }\n\n    function find(elm,selector) {\n        if (!selector) {\n            selector = elm;\n            elm = document.body;\n        }\n        if (matches(elm,selector)) {\n            return elm;\n        } else {\n            return descendant(elm, selector);\n        }\n    }\n\n    function findAll(elm,selector) {\n        if (!selector) {\n            selector = elm;\n            elm = document.body;\n        }\n        return descendants(elm, selector);\n    }\n\n    function firstChild(elm, selector, first) {\n        var childNodes = elm.childNodes,\n            node = childNodes[0];\n        while (node) {\n            if (node.nodeType == 1) {\n                if (!selector || matches(node, selector)) {\n                    return node;\n                }\n                if (first) {\n                    break;\n                }\n            }\n            node = node.nextSibling;\n        }\n\n        return null;\n    }\n\n    function lastChild(elm, selector, last) {\n        var childNodes = elm.childNodes,\n            node = childNodes[childNodes.length - 1];\n        while (node) {\n            if (node.nodeType == 1) {\n                if (!selector || matches(node, selector)) {\n                    return node;\n                }\n                if (last) {\n                    break;\n                }\n            }\n            node = node.previousSibling;\n        }\n\n        return null;\n    }\n\n    function matches(elm, selector) {\n        if (!selector || !elm || elm.nodeType !== 1) {\n            return false\n        }\n\n        if (langx.isString(selector)) {\n            try {\n                return nativeMatchesSelector.call(elm, selector.replace(/\\[([^=]+)=\\s*([^'\"\\]]+?)\\s*\\]/g, '[$1=\"$2\"]'));\n            } catch (matchError) {\n                //console.log(matchError);\n            }\n            return local.match(elm, selector);\n        } else if (langx.isArrayLike(selector)) {\n            return langx.inArray(elm,selector);\n        } else if (langx.isPlainObject(selector)){    \n            return local.check(elm, selector);\n        } else {\n            return elm === selector;\n        }\n\n    }\n\n    function nextSibling(elm, selector, adjacent) {\n        var node = elm.nextSibling;\n        while (node) {\n            if (node.nodeType == 1) {\n                if (!selector || matches(node, selector)) {\n                    return node;\n                }\n                if (adjacent) {\n                    break;\n                }\n            }\n            node = node.nextSibling;\n        }\n        return null;\n    }\n\n    function nextSiblings(elm, selector) {\n        var node = elm.nextSibling,\n            ret = [];\n        while (node) {\n            if (node.nodeType == 1) {\n                if (!selector || matches(node, selector)) {\n                    ret.push(node);\n                }\n            }\n            node = node.nextSibling;\n        }\n        return ret;\n    }\n\n\n    function parent(elm, selector) {\n        var node = elm.parentNode;\n        if (node && (!selector || matches(node, selector))) {\n            return node;\n        }\n\n        return null;\n    }\n\n    function previousSibling(elm, selector, adjacent) {\n        var node = elm.previousSibling;\n        while (node) {\n            if (node.nodeType == 1) {\n                if (!selector || matches(node, selector)) {\n                    return node;\n                }\n                if (adjacent) {\n                    break;\n                }\n            }\n            node = node.previousSibling;\n        }\n        return null;\n    }\n\n    function previousSiblings(elm, selector) {\n        var node = elm.previousSibling,\n            ret = [];\n        while (node) {\n            if (node.nodeType == 1) {\n                if (!selector || matches(node, selector)) {\n                    ret.push(node);\n                }\n            }\n            node = node.previousSibling;\n        }\n        return ret;\n    }\n\n    function siblings(elm, selector) {\n        var node = elm.parentNode.firstChild,\n            ret = [];\n        while (node) {\n            if (node.nodeType == 1 && node !== elm) {\n                if (!selector || matches(node, selector)) {\n                    ret.push(node);\n                }\n            }\n            node = node.nextSibling;\n        }\n        return ret;\n    }\n\n    var finder = function() {\n        return finder;\n    };\n\n    langx.mixin(finder, {\n\n        ancestor: ancestor,\n\n        ancestors: ancestors,\n\n        byId: byId,\n\n        children: children,\n\n        closest: closest,\n\n        descendant: descendant,\n\n        descendants: descendants,\n\n        find: find,\n\n        findAll: findAll,\n\n        firstChild: firstChild,\n\n        lastChild: lastChild,\n\n        matches: matches,\n\n        nextSibling: nextSibling,\n\n        nextSiblings: nextSiblings,\n\n        parent: parent,\n\n        previousSibling: previousSibling,\n\n        previousSiblings: previousSiblings,\n\n        pseudos: local.pseudos,\n\n        siblings: siblings\n    });\n\n    return skylark.finder = finder;\n});\n"]}