{"version":3,"sources":["geom.js"],"names":["define","skylark","langx","noder","styler","scrollbarWidth","undefined","cachedScrollbarWidth","w1","w2","div","createFragment","innerDiv","childNodes","append","document","body","offsetWidth","css","clientWidth","remove","borderExtents","elm","s","getComputedStyle","left","px","borderLeftWidth","top","borderTopWidth","right","borderRightWidth","bottom","borderBottomWidth","boundingPosition","coords","rootNodeRE","test","nodeName","getBoundingClientRect","parent","offsetParent","parentOffset","mex","marginExtents","pbex","relativePosition","this","boundingRect","size","clientHeight","value","clientSize","height","dimension","width","isBorderBox","props","bex","pex","paddingExtents","contentRect","cs","getDocumentSize","doc","documentElement","max","Math","scrollWidth","scrollHeight","offsetHeight","marginLeft","marginTop","marginRight","marginBottom","marginRect","obj","relativeRect","me","marginSize","paddingLeft","paddingTop","paddingRight","paddingBottom","pagePosition","window","pageXOffset","pageYOffset","pageRect","round","offset","scrollIntoView","align","getOffset","rootElm","x","y","nodeType","offsetLeft","offsetTop","parentWidth","parentHeight","parentElm","parentNode","pos","scrollLeft","scrollTop","hasScrollLeft","scrollTo","scrollY","hasScrollTop","scrollX","isWindow","innerWidth","innerHeight","isDocument","geom","toPixel","mixin"],"mappings":"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","file":"../geom.js","sourcesContent":["define([\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./noder\",\r\n    \"./styler\"\r\n], function(skylark, langx, noder, styler) {\r\n    var rootNodeRE = /^(?:body|html)$/i,\r\n        px = langx.toPixel,\r\n        offsetParent = noder.offsetParent,\r\n        cachedScrollbarWidth;\r\n\r\n    function scrollbarWidth() {\r\n        if (cachedScrollbarWidth !== undefined) {\r\n            return cachedScrollbarWidth;\r\n        }\r\n        var w1, w2,\r\n            div = noder.createFragment(\"<div style=\" +\r\n                \"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\r\n                \"<div style='height:300px;width:auto;'></div></div>\")[0],\r\n            innerDiv = div.childNodes[0];\r\n\r\n        noder.append(document.body, div);\r\n\r\n        w1 = innerDiv.offsetWidth;\r\n\r\n        styler.css(div, \"overflow\", \"scroll\");\r\n\r\n        w2 = innerDiv.offsetWidth;\r\n\r\n        if (w1 === w2) {\r\n            w2 = div[0].clientWidth;\r\n        }\r\n\r\n        noder.remove(div);\r\n\r\n        return (cachedScrollbarWidth = w1 - w2);\r\n    }\r\n    /*\r\n     * Get the widths of each border of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function borderExtents(elm) {\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.borderLeftWidth, elm),\r\n            top: px(s.borderTopWidth, elm),\r\n            right: px(s.borderRightWidth, elm),\r\n            bottom: px(s.borderBottomWidth, elm)\r\n        }\r\n    }\r\n\r\n    //viewport coordinate\r\n    /*\r\n     * Get or set the viewport position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingPosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the viewport rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            return elm.getBoundingClientRect()\r\n        } else {\r\n            boundingPosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the height of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function clientHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).height;\r\n        } else {\r\n            return clientSize(elm, {\r\n                height: value\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            return {\r\n                width: elm.clientWidth,\r\n                height: elm.clientHeight\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width - pex.left - pex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height - pex.top - pex.bottom;\r\n                }\r\n            } else {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height + bex.top + bex.bottom;\r\n                }\r\n\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n        return {\r\n            width: elm.clientWidth,\r\n            height: elm.clientHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get or set the width of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).width;\r\n        } else {\r\n            clientSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the rect of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentRect(elm) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n\r\n        //// On Opera, offsetLeft includes the parent's border\r\n        //if(has(\"opera\")){\r\n        //    pe.l += be.l;\r\n        //    pe.t += be.t;\r\n        //}\r\n        return {\r\n            left: pex.left,\r\n            top: pex.top,\r\n            width: cs.width - pex.left - pex.right,\r\n            height: cs.height - pex.top - pex.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLDocument} doc\r\n     */\r\n    function getDocumentSize(doc) {\r\n        var documentElement = doc.documentElement,\r\n            body = doc.body,\r\n            max = Math.max,\r\n            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),\r\n            clientWidth = max(documentElement.clientWidth, body.clientWidth),\r\n            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),\r\n            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),\r\n            clientHeight = max(documentElement.clientHeight, body.clientHeight),\r\n            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\r\n\r\n        return {\r\n            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\r\n            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function height(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).height;\r\n        } else {\r\n            size(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each margin of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function marginExtents(elm) {\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.marginLeft),\r\n            top: px(s.marginTop),\r\n            right: px(s.marginRight),\r\n            bottom: px(s.marginBottom),\r\n        }\r\n    }\r\n\r\n\r\n    function marginRect(elm) {\r\n        var obj = this.relativeRect(elm),\r\n            me = this.marginExtents(elm);\r\n\r\n        return {\r\n            left: obj.left,\r\n            top: obj.top,\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n\r\n    function marginSize(elm) {\r\n        var obj = this.size(elm),\r\n            me = this.marginExtents(elm);\r\n\r\n        return {\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each padding of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function paddingExtents(elm) {\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.paddingLeft),\r\n            top: px(s.paddingTop),\r\n            right: px(s.paddingRight),\r\n            bottom: px(s.paddingBottom),\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    //coordinate to the document\r\n    function pagePosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = pagePosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function pageRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset,\r\n                width: Math.round(obj.width),\r\n                height: Math.round(obj.height)\r\n            }\r\n        } else {\r\n            pagePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the position of the specified element border box , relative to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    // coordinate relative to it's parent\r\n    function relativePosition(elm, coords) {\r\n        if (coords == undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingPosition(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left\r\n            }\r\n        } else {\r\n            var props = {\r\n                top: coords.top,\r\n                left: coords.left\r\n            }\r\n\r\n            if (styler.css(elm, \"position\") == \"static\") {\r\n                props['position'] = \"relative\";\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the rect of the specified element border box , relatived to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function relativeRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingRect(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left,\r\n                width: offset.width,\r\n                height: offset.height\r\n            }\r\n        } else {\r\n            relativePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Scroll the specified element into view.\r\n     * @param {HTMLElement} elm\r\n     * @param {} align\r\n     */\r\n    function scrollIntoView(elm, align) {\r\n        function getOffset(elm, rootElm) {\r\n            var x, y, parent = elm;\r\n\r\n            x = y = 0;\r\n            while (parent && parent != rootElm && parent.nodeType) {\r\n                x += parent.offsetLeft || 0;\r\n                y += parent.offsetTop || 0;\r\n                parent = parent.offsetParent;\r\n            }\r\n\r\n            return { x: x, y: y };\r\n        }\r\n\r\n        var parentElm = elm.parentNode;\r\n        var x, y, width, height, parentWidth, parentHeight;\r\n        var pos = getOffset(elm, parentElm);\r\n\r\n        x = pos.x;\r\n        y = pos.y;\r\n        width = elm.offsetWidth;\r\n        height = elm.offsetHeight;\r\n        parentWidth = parentElm.clientWidth;\r\n        parentHeight = parentElm.clientHeight;\r\n\r\n        if (align == \"end\") {\r\n            x -= parentWidth - width;\r\n            y -= parentHeight - height;\r\n        } else if (align == \"center\") {\r\n            x -= (parentWidth / 2) - (width / 2);\r\n            y -= (parentHeight / 2) - (height / 2);\r\n        }\r\n\r\n        parentElm.scrollLeft = x;\r\n        parentElm.scrollTop = y;\r\n\r\n        return this;\r\n    }\r\n    /*\r\n     * Get or set the current horizontal position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollLeft(elm, value) {\r\n        var hasScrollLeft = \"scrollLeft\" in elm;\r\n        if (value === undefined) {\r\n            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset\r\n        } else {\r\n            if (hasScrollLeft) {\r\n                elm.scrollLeft = value;\r\n            } else {\r\n                elm.scrollTo(value, elm.scrollY);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or the current vertical position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollTop(elm, value) {\r\n        var hasScrollTop = \"scrollTop\" in elm;\r\n\r\n        if (value === undefined) {\r\n            return hasScrollTop ? elm.scrollTop : elm.pageYOffset\r\n        } else {\r\n            if (hasScrollTop) {\r\n                elm.scrollTop = value;\r\n            } else {\r\n                elm.scrollTo(elm.scrollX, value);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject}dimension\r\n     */\r\n    function size(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            if (langx.isWindow(elm)) {\r\n                return {\r\n                    width: elm.innerWidth,\r\n                    height: elm.innerHeight\r\n                }\r\n\r\n            } else if (langx.isDocument(elm)) {\r\n                return getDocumentSize(document);\r\n            } else {\r\n                return {\r\n                    width: elm.offsetWidth,\r\n                    height: elm.offsetHeight\r\n                }\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm),\r\n                    bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function width(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).width;\r\n        } else {\r\n            size(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n    \r\n// in development start\r\n    function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){\r\n        // summary:\r\n        //      Given a list of spots to put node, put it at the first spot where it fits,\r\n        //      of if it doesn't fit anywhere then the place with the least overflow\r\n        // choices: Array\r\n        //      Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }\r\n        //      Above example says to put the top-left corner of the node at (10,20)\r\n        // layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)\r\n        //      for things like tooltip, they are displayed differently (and have different dimensions)\r\n        //      based on their orientation relative to the parent.   This adjusts the popup based on orientation.\r\n        //      It also passes in the available size for the popup, which is useful for tooltips to\r\n        //      tell them that their width is limited to a certain amount.   layoutNode() may return a value expressing\r\n        //      how much the popup had to be modified to fit into the available space.   This is used to determine\r\n        //      what the best placement is.\r\n        // aroundNodeCoords: Object\r\n        //      Size of aroundNode, ex: {w: 200, h: 50}\r\n\r\n        // get {x: 10, y: 10, w: 100, h:100} type obj representing position of\r\n        // viewport over document\r\n\r\n        var doc = noder.ownerDoc(node),\r\n            win = noder.ownerWindow(doc),\r\n            view = geom.size(win);\r\n\r\n        view.left = 0;\r\n        view.top = 0;\r\n\r\n        if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != \"body\"){\r\n            doc.body.appendChild(node);\r\n        }\r\n\r\n        var best = null;\r\n\r\n        some.apply(choices, function(choice){\r\n            var corner = choice.corner;\r\n            var pos = choice.pos;\r\n            var overflow = 0;\r\n\r\n            // calculate amount of space available given specified position of node\r\n            var spaceAvailable = {\r\n                w: {\r\n                    'L': view.left + view.width - pos.x,\r\n                    'R': pos.x - view.left,\r\n                    'M': view.width\r\n                }[corner.charAt(1)],\r\n\r\n                h: {\r\n                    'T': view.top + view.height - pos.y,\r\n                    'B': pos.y - view.top,\r\n                    'M': view.height\r\n                }[corner.charAt(0)]\r\n            };\r\n\r\n            if(layoutNode){\r\n                var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);\r\n                overflow = typeof res == \"undefined\" ? 0 : res;\r\n            }\r\n\r\n            var bb = geom.size(node);\r\n\r\n            // coordinates and size of node with specified corner placed at pos,\r\n            // and clipped by viewport\r\n            var\r\n                startXpos = {\r\n                    'L': pos.x,\r\n                    'R': pos.x - bb.width,\r\n                    'M': Math.max(view.left, Math.min(view.left + view.width, pos.x + (bb.width >> 1)) - bb.width) // M orientation is more flexible\r\n                }[corner.charAt(1)],\r\n\r\n                startYpos = {\r\n                    'T': pos.y,\r\n                    'B': pos.y - bb.height,\r\n                    'M': Math.max(view.top, Math.min(view.top + view.height, pos.y + (bb.height >> 1)) - bb.height)\r\n                }[corner.charAt(0)],\r\n\r\n                startX = Math.max(view.left, startXpos),\r\n                startY = Math.max(view.top, startYpos),\r\n                endX = Math.min(view.left + view.width, startXpos + bb.width),\r\n                endY = Math.min(view.top + view.height, startYpos + bb.height),\r\n                width = endX - startX,\r\n                height = endY - startY;\r\n\r\n            overflow += (bb.width - width) + (bb.height - height);\r\n\r\n            if(best == null || overflow < best.overflow){\r\n                best = {\r\n                    corner: corner,\r\n                    aroundCorner: choice.aroundCorner,\r\n                    left: startX,\r\n                    top: startY,\r\n                    width: width,\r\n                    height: height,\r\n                    overflow: overflow,\r\n                    spaceAvailable: spaceAvailable\r\n                };\r\n            }\r\n\r\n            return !overflow;\r\n        });\r\n\r\n        // In case the best position is not the last one we checked, need to call\r\n        // layoutNode() again.\r\n        if(best.overflow && layoutNode){\r\n            layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);\r\n        }\r\n\r\n\r\n        geom.boundingPosition(node,best);\r\n\r\n        return best;\r\n    }\r\n\r\n    function at(node, pos, corners, padding, layoutNode){\r\n        var choices = map.apply(corners, function(corner){\r\n            var c = {\r\n                corner: corner,\r\n                aroundCorner: reverse[corner],  // so TooltipDialog.orient() gets aroundCorner argument set\r\n                pos: {x: pos.x,y: pos.y}\r\n            };\r\n            if(padding){\r\n                c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;\r\n                c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;\r\n            }\r\n            return c;\r\n        });\r\n\r\n        return _place(node, choices, layoutNode);\r\n    }\r\n\r\n    function around(\r\n        /*DomNode*/     node,\r\n        /*DomNode|__Rectangle*/ anchor,\r\n        /*String[]*/    positions,\r\n        /*Boolean*/     leftToRight,\r\n        /*Function?*/   layoutNode){\r\n\r\n        // summary:\r\n        //      Position node adjacent or kitty-corner to anchor\r\n        //      such that it's fully visible in viewport.\r\n        // description:\r\n        //      Place node such that corner of node touches a corner of\r\n        //      aroundNode, and that node is fully visible.\r\n        // anchor:\r\n        //      Either a DOMNode or a rectangle (object with x, y, width, height).\r\n        // positions:\r\n        //      Ordered list of positions to try matching up.\r\n        //\r\n        //      - before: places drop down to the left of the anchor node/widget, or to the right in the case\r\n        //          of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down\r\n        //          with the top of the anchor, or the bottom of the drop down with bottom of the anchor.\r\n        //      - after: places drop down to the right of the anchor node/widget, or to the left in the case\r\n        //          of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down\r\n        //          with the top of the anchor, or the bottom of the drop down with bottom of the anchor.\r\n        //      - before-centered: centers drop down to the left of the anchor node/widget, or to the right\r\n        //          in the case of RTL scripts like Hebrew and Arabic\r\n        //      - after-centered: centers drop down to the right of the anchor node/widget, or to the left\r\n        //          in the case of RTL scripts like Hebrew and Arabic\r\n        //      - above-centered: drop down is centered above anchor node\r\n        //      - above: drop down goes above anchor node, left sides aligned\r\n        //      - above-alt: drop down goes above anchor node, right sides aligned\r\n        //      - below-centered: drop down is centered above anchor node\r\n        //      - below: drop down goes below anchor node\r\n        //      - below-alt: drop down goes below anchor node, right sides aligned\r\n        // layoutNode: Function(node, aroundNodeCorner, nodeCorner)\r\n        //      For things like tooltip, they are displayed differently (and have different dimensions)\r\n        //      based on their orientation relative to the parent.   This adjusts the popup based on orientation.\r\n        // leftToRight:\r\n        //      True if widget is LTR, false if widget is RTL.   Affects the behavior of \"above\" and \"below\"\r\n        //      positions slightly.\r\n        // example:\r\n        //  |   placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});\r\n        //      This will try to position node such that node's top-left corner is at the same position\r\n        //      as the bottom left corner of the aroundNode (ie, put node below\r\n        //      aroundNode, with left edges aligned).   If that fails it will try to put\r\n        //      the bottom-right corner of node where the top right corner of aroundNode is\r\n        //      (ie, put node above aroundNode, with right edges aligned)\r\n        //\r\n\r\n        // If around is a DOMNode (or DOMNode id), convert to coordinates.\r\n        var aroundNodePos;\r\n        if(typeof anchor == \"string\" || \"offsetWidth\" in anchor || \"ownerSVGElement\" in anchor){\r\n            aroundNodePos = domGeometry.position(anchor, true);\r\n\r\n            // For above and below dropdowns, subtract width of border so that popup and aroundNode borders\r\n            // overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border\r\n            // width of either anchor or popup because in both cases the border may be on an inner node.\r\n            if(/^(above|below)/.test(positions[0])){\r\n                var anchorBorder = domGeometry.getBorderExtents(anchor),\r\n                    anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},\r\n                    nodeBorder =  domGeometry.getBorderExtents(node),\r\n                    nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};\r\n                aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);\r\n                aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +\r\n                    Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);\r\n            }\r\n        }else{\r\n            aroundNodePos = anchor;\r\n        }\r\n\r\n        // Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)\r\n        if(anchor.parentNode){\r\n            // ignore nodes between position:relative and position:absolute\r\n            var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == \"absolute\";\r\n            var parent = anchor.parentNode;\r\n            while(parent && parent.nodeType == 1 && parent.nodeName != \"BODY\"){  //ignoring the body will help performance\r\n                var parentPos = domGeometry.position(parent, true),\r\n                    pcs = domStyle.getComputedStyle(parent);\r\n                if(/relative|absolute/.test(pcs.position)){\r\n                    sawPosAbsolute = false;\r\n                }\r\n                if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){\r\n                    var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);\r\n                    var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);\r\n                    aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);\r\n                    aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);\r\n                    aroundNodePos.h = bottomYCoord - aroundNodePos.y;\r\n                    aroundNodePos.w = rightXCoord - aroundNodePos.x;\r\n                }\r\n                if(pcs.position == \"absolute\"){\r\n                    sawPosAbsolute = true;\r\n                }\r\n                parent = parent.parentNode;\r\n            }\r\n        }           \r\n\r\n        var x = aroundNodePos.x,\r\n            y = aroundNodePos.y,\r\n            width = \"w\" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),\r\n            height = \"h\" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated(\"place.around: dijit/place.__Rectangle: { x:\"+x+\", y:\"+y+\", height:\"+aroundNodePos.height+\", width:\"+width+\" } has been deprecated.  Please use { x:\"+x+\", y:\"+y+\", h:\"+aroundNodePos.height+\", w:\"+width+\" }\", \"\", \"2.0\"), aroundNodePos.h = aroundNodePos.height);\r\n\r\n        // Convert positions arguments into choices argument for _place()\r\n        var choices = [];\r\n        function push(aroundCorner, corner){\r\n            choices.push({\r\n                aroundCorner: aroundCorner,\r\n                corner: corner,\r\n                pos: {\r\n                    x: {\r\n                        'L': x,\r\n                        'R': x + width,\r\n                        'M': x + (width >> 1)\r\n                    }[aroundCorner.charAt(1)],\r\n                    y: {\r\n                        'T': y,\r\n                        'B': y + height,\r\n                        'M': y + (height >> 1)\r\n                    }[aroundCorner.charAt(0)]\r\n                }\r\n            })\r\n        }\r\n        array.forEach(positions, function(pos){\r\n            var ltr =  leftToRight;\r\n            switch(pos){\r\n                case \"above-centered\":\r\n                    push(\"TM\", \"BM\");\r\n                    break;\r\n                case \"below-centered\":\r\n                    push(\"BM\", \"TM\");\r\n                    break;\r\n                case \"after-centered\":\r\n                    ltr = !ltr;\r\n                    // fall through\r\n                case \"before-centered\":\r\n                    push(ltr ? \"ML\" : \"MR\", ltr ? \"MR\" : \"ML\");\r\n                    break;\r\n                case \"after\":\r\n                    ltr = !ltr;\r\n                    // fall through\r\n                case \"before\":\r\n                    push(ltr ? \"TL\" : \"TR\", ltr ? \"TR\" : \"TL\");\r\n                    push(ltr ? \"BL\" : \"BR\", ltr ? \"BR\" : \"BL\");\r\n                    break;\r\n                case \"below-alt\":\r\n                    ltr = !ltr;\r\n                    // fall through\r\n                case \"below\":\r\n                    // first try to align left borders, next try to align right borders (or reverse for RTL mode)\r\n                    push(ltr ? \"BL\" : \"BR\", ltr ? \"TL\" : \"TR\");\r\n                    push(ltr ? \"BR\" : \"BL\", ltr ? \"TR\" : \"TL\");\r\n                    break;\r\n                case \"above-alt\":\r\n                    ltr = !ltr;\r\n                    // fall through\r\n                case \"above\":\r\n                    // first try to align left borders, next try to align right borders (or reverse for RTL mode)\r\n                    push(ltr ? \"TL\" : \"TR\", ltr ? \"BL\" : \"BR\");\r\n                    push(ltr ? \"TR\" : \"TL\", ltr ? \"BR\" : \"BL\");\r\n                    break;\r\n                default:\r\n                    // To assist dijit/_base/place, accept arguments of type {aroundCorner: \"BL\", corner: \"TL\"}.\r\n                    // Not meant to be used directly.  Remove for 2.0.\r\n                    push(pos.aroundCorner, pos.corner);\r\n            }\r\n        });\r\n\r\n        var position = _place(node, choices, layoutNode, {w: width, h: height});\r\n        position.aroundNodePos = aroundNodePos;\r\n\r\n        return position;\r\n    }\r\n// in development end\r\n\r\n    function geom() {\r\n        return geom;\r\n    }\r\n\r\n    langx.mixin(geom, {\r\n        borderExtents: borderExtents,\r\n        //viewport coordinate\r\n        boundingPosition: boundingPosition,\r\n\r\n        boundingRect: boundingRect,\r\n\r\n        clientHeight: clientHeight,\r\n\r\n        clientSize: clientSize,\r\n\r\n        clientWidth: clientWidth,\r\n\r\n        contentRect: contentRect,\r\n\r\n        getDocumentSize: getDocumentSize,\r\n\r\n        height: height,\r\n\r\n        marginExtents: marginExtents,\r\n\r\n        marginRect: marginRect,\r\n\r\n        marginSize: marginSize,\r\n\r\n        offsetParent: offsetParent,\r\n\r\n        paddingExtents: paddingExtents,\r\n\r\n        //coordinate to the document\r\n        pagePosition: pagePosition,\r\n\r\n        pageRect: pageRect,\r\n\r\n        // coordinate relative to it's parent\r\n        relativePosition: relativePosition,\r\n\r\n        relativeRect: relativeRect,\r\n\r\n        scrollbarWidth: scrollbarWidth,\r\n\r\n        scrollIntoView: scrollIntoView,\r\n\r\n        scrollLeft: scrollLeft,\r\n\r\n        scrollTop: scrollTop,\r\n\r\n        size: size,\r\n\r\n        width: width\r\n    });\r\n\r\n    return skylark.geom = geom;\r\n});"]}