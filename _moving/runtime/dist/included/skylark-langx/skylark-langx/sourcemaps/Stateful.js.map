{"version":3,"sources":["Stateful.js"],"names":["define","Evented","Stateful","inherit","init","attributes","options","attrs","this","cid","uniqueId","cidPrefix","collection","parse","defaults","result","mixin","set","changed","validationError","idAttribute","toJSON","clone","get","attr","has","key","val","_validate","unset","silent","changes","changing","_changing","_previousAttributes","current","prev","isEqual","push","id","length","_pending","i","trigger","clear","hasChanged","isEmptyObject","undefined","changedAttributes","diff","old","previous","previousAttributes","constructor","isNew","isValid","validate","error"],"mappings":"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","file":"../Stateful.js","sourcesContent":["define([\r\n\t\"./Evented\"\r\n],function(Evented){\r\n    var Stateful = Evented.inherit({\r\n        init : function(attributes, options) {\r\n            var attrs = attributes || {};\r\n            options || (options = {});\r\n            this.cid = uniqueId(this.cidPrefix);\r\n            this.attributes = {};\r\n            if (options.collection) this.collection = options.collection;\r\n            if (options.parse) attrs = this.parse(attrs, options) || {};\r\n            var defaults = result(this, 'defaults');\r\n            attrs = mixin({}, defaults, attrs);\r\n            this.set(attrs, options);\r\n            this.changed = {};\r\n        },\r\n\r\n        // A hash of attributes whose current and previous value differ.\r\n        changed: null,\r\n\r\n        // The value returned during the last failed validation.\r\n        validationError: null,\r\n\r\n        // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\r\n        // CouchDB users may want to set this to `\"_id\"`.\r\n        idAttribute: 'id',\r\n\r\n        // The prefix is used to create the client id which is used to identify models locally.\r\n        // You may want to override this if you're experiencing name clashes with model ids.\r\n        cidPrefix: 'c',\r\n\r\n\r\n        // Return a copy of the model's `attributes` object.\r\n        toJSON: function(options) {\r\n          return clone(this.attributes);\r\n        },\r\n\r\n\r\n        // Get the value of an attribute.\r\n        get: function(attr) {\r\n          return this.attributes[attr];\r\n        },\r\n\r\n        // Returns `true` if the attribute contains a value that is not null\r\n        // or undefined.\r\n        has: function(attr) {\r\n          return this.get(attr) != null;\r\n        },\r\n\r\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\r\n        // the core primitive operation of a model, updating the data and notifying\r\n        // anyone who needs to know about the change in state. The heart of the beast.\r\n        set: function(key, val, options) {\r\n          if (key == null) return this;\r\n\r\n          // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n          var attrs;\r\n          if (typeof key === 'object') {\r\n            attrs = key;\r\n            options = val;\r\n          } else {\r\n            (attrs = {})[key] = val;\r\n          }\r\n\r\n          options || (options = {});\r\n\r\n          // Run validation.\r\n          if (!this._validate(attrs, options)) return false;\r\n\r\n          // Extract attributes and options.\r\n          var unset      = options.unset;\r\n          var silent     = options.silent;\r\n          var changes    = [];\r\n          var changing   = this._changing;\r\n          this._changing = true;\r\n\r\n          if (!changing) {\r\n            this._previousAttributes = clone(this.attributes);\r\n            this.changed = {};\r\n          }\r\n\r\n          var current = this.attributes;\r\n          var changed = this.changed;\r\n          var prev    = this._previousAttributes;\r\n\r\n          // For each `set` attribute, update or delete the current value.\r\n          for (var attr in attrs) {\r\n            val = attrs[attr];\r\n            if (!isEqual(current[attr], val)) changes.push(attr);\r\n            if (!isEqual(prev[attr], val)) {\r\n              changed[attr] = val;\r\n            } else {\r\n              delete changed[attr];\r\n            }\r\n            unset ? delete current[attr] : current[attr] = val;\r\n          }\r\n\r\n          // Update the `id`.\r\n          if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);\r\n\r\n          // Trigger all relevant attribute changes.\r\n          if (!silent) {\r\n            if (changes.length) this._pending = options;\r\n            for (var i = 0; i < changes.length; i++) {\r\n              this.trigger('change:' + changes[i], this, current[changes[i]], options);\r\n            }\r\n          }\r\n\r\n          // You might be wondering why there's a `while` loop here. Changes can\r\n          // be recursively nested within `\"change\"` events.\r\n          if (changing) return this;\r\n          if (!silent) {\r\n            while (this._pending) {\r\n              options = this._pending;\r\n              this._pending = false;\r\n              this.trigger('change', this, options);\r\n            }\r\n          }\r\n          this._pending = false;\r\n          this._changing = false;\r\n          return this;\r\n        },\r\n\r\n        // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\r\n        // if the attribute doesn't exist.\r\n        unset: function(attr, options) {\r\n          return this.set(attr, void 0, mixin({}, options, {unset: true}));\r\n        },\r\n\r\n        // Clear all attributes on the model, firing `\"change\"`.\r\n        clear: function(options) {\r\n          var attrs = {};\r\n          for (var key in this.attributes) attrs[key] = void 0;\r\n          return this.set(attrs, mixin({}, options, {unset: true}));\r\n        },\r\n\r\n        // Determine if the model has changed since the last `\"change\"` event.\r\n        // If you specify an attribute name, determine if that attribute has changed.\r\n        hasChanged: function(attr) {\r\n          if (attr == null) return !isEmptyObject(this.changed);\r\n          return this.changed[attr] !== undefined;\r\n        },\r\n\r\n        // Return an object containing all the attributes that have changed, or\r\n        // false if there are no changed attributes. Useful for determining what\r\n        // parts of a view need to be updated and/or what attributes need to be\r\n        // persisted to the server. Unset attributes will be set to undefined.\r\n        // You can also pass an attributes object to diff against the model,\r\n        // determining if there *would be* a change.\r\n        changedAttributes: function(diff) {\r\n          if (!diff) return this.hasChanged() ? clone(this.changed) : false;\r\n          var old = this._changing ? this._previousAttributes : this.attributes;\r\n          var changed = {};\r\n          for (var attr in diff) {\r\n            var val = diff[attr];\r\n            if (isEqual(old[attr], val)) continue;\r\n            changed[attr] = val;\r\n          }\r\n          return !isEmptyObject(changed) ? changed : false;\r\n        },\r\n\r\n        // Get the previous value of an attribute, recorded at the time the last\r\n        // `\"change\"` event was fired.\r\n        previous: function(attr) {\r\n          if (attr == null || !this._previousAttributes) return null;\r\n          return this._previousAttributes[attr];\r\n        },\r\n\r\n        // Get all of the attributes of the model at the time of the previous\r\n        // `\"change\"` event.\r\n        previousAttributes: function() {\r\n          return clone(this._previousAttributes);\r\n        },\r\n\r\n        // Create a new model with identical attributes to this one.\r\n        clone: function() {\r\n          return new this.constructor(this.attributes);\r\n        },\r\n\r\n        // A model is new if it has never been saved to the server, and lacks an id.\r\n        isNew: function() {\r\n          return !this.has(this.idAttribute);\r\n        },\r\n\r\n        // Check if the model is currently in a valid state.\r\n        isValid: function(options) {\r\n          return this._validate({}, mixin({}, options, {validate: true}));\r\n        },\r\n\r\n        // Run validation against the next complete set of model attributes,\r\n        // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\r\n        _validate: function(attrs, options) {\r\n          if (!options.validate || !this.validate) return true;\r\n          attrs = mixin({}, this.attributes, attrs);\r\n          var error = this.validationError = this.validate(attrs, options) || null;\r\n          if (!error) return true;\r\n          this.trigger('invalid', this, error, mixin(options, {validationError: error}));\r\n          return false;\r\n        }\r\n    });\r\n\r\n\treturn Stateful;\r\n});"]}