{"version":3,"sources":["filer.js"],"names":["define","skylark","langx","datax","eventer","styler","dropzone","elm","params","hoverClass","droppedCallback","dropped","enterdCount","on","e","dataTransfer","types","indexOf","stop","addClass","removeClass","items","length","webkitGetAsEntry","getAsEntry","webentry","all","map","item","then","files","this","pastezone","pastedCallback","pasted","originalEvent","clipboardData","each","index","file","getAsFile","push","picker","preventDefault","select","selectFiles","pickedFiles","i","size","maxFileSize","splice","fileSelected","directory","multiple","picked","fileInput","input","document","createElement","type","style","position","left","top","opacity","body","appendChild","onchange","entries","target","webkitEntries","Array","prototype","slice","call","value","webkitdirectory","click","upload","initDataSettings","o","chunkedUpload","data","initXHRData","formData","multipart","paramName","headers","mixin","contentRange","FormData","blob","append","name","uploadName","encodeURI","contentType","getUploadedBytes","jqXHR","range","getResponseHeader","parts","split","upperBytesPos","parseInt","BitrateTimer","timestamp","Date","now","getTime","loaded","bitrate","getBitrate","interval","timeDiff","options","testOnly","uploadedBytes","fs","ub","mcs","maxChunkSize","blobSlice","dfd","Deferred","promise","error","i18n","_getXHRPromise","context","currentLoaded","_progress","chunkSize","$","ajax","done","result","textStatus","progress","lengthComputable","total","resolveWith","fail","errorThrown","rejectWith","abort","xoptions","undefined","singleFileUploads","limitMultiFileUploads","limitMultiFileUploadSize","limitMultiFileUploadSizeOverhead","sequentialUploads","limitConcurrentUploads","recalculateProgress","progressInterval","bitrateInterval","autoUpload","messages","message","toString","key","replace","form","serializeArray","add","isDefaultPrevented","fileupload","process","submit","processData","cache","Blob","webkitSlice","mozSlice","apply","arguments","Xhr","request","url","_bitrateTimer","jqXhr","concat","attr","one","entry","path","d","onError","reject","isFile","relativePath","resolve","isDirectory","dirReader","createReader","readEntries","filer","readFile","reader","FileReader","onload","evt","onerror","code","alert","asArrayBuffer","readAsArrayBuffer","asDataUrl","readAsDataURL","asText","readAsText","writeFile","window","navigator","msSaveBlob","isString","dataURItoBlob","a","URL","createObjectURL","href","setAttribute","dispatchEvent","CustomEvent"],"mappings":"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","file":"../filer.js","sourcesContent":["define([\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./datax\",\r\n    \"./eventer\",\r\n    \"./styler\"\r\n], function(skylark, langx, datax, eventer, styler) {\r\n    var concat = Array.prototype.concat,\r\n        on = eventer.on,\r\n        attr = eventer.attr,\r\n        Deferred = langx.Deferred,\r\n\r\n        fileInput,\r\n        fileInputForm,\r\n        fileSelected,\r\n        maxFileSize = 1 / 0;\r\n\r\n\r\n    var webentry = (function() {\r\n        function one(entry, path) {\r\n            var d = new Deferred(),\r\n                onError = function(e) {\r\n                    d.reject(e);\r\n                };\r\n\r\n            path = path || '';\r\n            if (entry.isFile) {\r\n                entry.file(function(file) {\r\n                    file.relativePath = path;\r\n                    d.resolve(file);\r\n                }, onError);\r\n            } else if (entry.isDirectory) {\r\n                var dirReader = entry.createReader();\r\n                dirReader.readEntries(function(entries) {\r\n                    all(\r\n                        entries,\r\n                        path + entry.name + '/'\r\n                    ).then(function(files) {\r\n                        d.resolve(files);\r\n                    }).catch(onError);\r\n                }, onError);\r\n            } else {\r\n                // Return an empy list for file system items\r\n                // other than files or directories:\r\n                d.resolve([]);\r\n            }\r\n            return d.promise;\r\n        }\r\n\r\n        function all(entries, path) {\r\n            return Deferred.all(\r\n                langx.map(entries, function(entry) {\r\n                    return one(entry, path);\r\n                })\r\n            ).then(function() {\r\n                return concat.apply([], arguments);\r\n            });\r\n        }\r\n\r\n        return {\r\n            one: one,\r\n            all: all\r\n        };\r\n    })();\r\n\r\n    function dataURLtoBlob(dataurl) {\r\n        var arr = dataurl.split(','),\r\n            mime = arr[0].match(/:(.*?);/)[1],\r\n            bstr = atob(arr[1]),\r\n            n = bstr.length,\r\n            u8arr = new Uint8Array(n);\r\n        while (n--) {\r\n            u8arr[n] = bstr.charCodeAt(n);\r\n        }\r\n        return new Blob([u8arr], { type: mime });\r\n    }\r\n    /*\r\n     * Make the specified element to could accept HTML5 file drag and drop.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} params\r\n     */\r\n    function dropzone(elm, params) {\r\n        params = params || {};\r\n        var hoverClass = params.hoverClass || \"dropzone\",\r\n            droppedCallback = params.dropped;\r\n\r\n        var enterdCount = 0;\r\n        on(elm, \"dragenter\", function(e) {\r\n            if (e.dataTransfer && e.dataTransfer.types.indexOf(\"Files\") > -1) {\r\n                eventer.stop(e);\r\n                enterdCount++;\r\n                styler.addClass(elm, hoverClass)\r\n            }\r\n        });\r\n\r\n        on(elm, \"dragover\", function(e) {\r\n            if (e.dataTransfer && e.dataTransfer.types.indexOf(\"Files\") > -1) {\r\n                eventer.stop(e);\r\n            }\r\n        });\r\n\r\n        on(elm, \"dragleave\", function(e) {\r\n            if (e.dataTransfer && e.dataTransfer.types.indexOf(\"Files\") > -1) {\r\n                enterdCount--\r\n                if (enterdCount == 0) {\r\n                    styler.removeClass(elm, hoverClass);\r\n                }\r\n            }\r\n        });\r\n\r\n        on(elm, \"drop\", function(e) {\r\n            if (e.dataTransfer && e.dataTransfer.types.indexOf(\"Files\") > -1) {\r\n                styler.removeClass(elm, hoverClass)\r\n                eventer.stop(e);\r\n                if (droppedCallback) {\r\n                    var items = e.dataTransfer.items;\r\n                    if (items && items.length && (items[0].webkitGetAsEntry ||\r\n                            items[0].getAsEntry)) {\r\n                        webentry.all(\r\n                            langx.map(items, function(item) {\r\n                                if (item.webkitGetAsEntry) {\r\n                                    return item.webkitGetAsEntry();\r\n                                }\r\n                                return item.getAsEntry();\r\n                            })\r\n                        ).then(droppedCallback);\r\n                    } else {\r\n                        droppedCallback(e.dataTransfer.files);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    function pastezone(elm, params) {\r\n        params = params || {};\r\n        var hoverClass = params.hoverClass || \"pastezone\",\r\n            pastedCallback = params.pasted;\r\n\r\n        on(elm, \"paste\", function(e) {\r\n            var items = e.originalEvent && e.originalEvent.clipboardData &&\r\n                e.originalEvent.clipboardData.items,\r\n                files = [];\r\n            if (items && items.length) {\r\n                langx.each(items, function(index, item) {\r\n                    var file = item.getAsFile && item.getAsFile();\r\n                    if (file) {\r\n                        files.push(file);\r\n                    }\r\n                });\r\n            }\r\n            if (pastedCallback && files.length) {\r\n                pastedCallback(files);\r\n            }\r\n        });\r\n\r\n        return this;\r\n    }\r\n    /*\r\n     * Make the specified element to pop-up the file selection dialog box when clicked , and read the contents the files selected from client file system by user.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} params\r\n     */\r\n    function picker(elm, params) {\r\n        on(elm, \"click\", function(e) {\r\n            e.preventDefault();\r\n            select(params);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    function select(params) {\r\n        params = params || {};\r\n        var directory = params.directory || false,\r\n            multiple = params.multiple || false,\r\n            fileSelected = params.picked;\r\n        if (!fileInput) {\r\n            var input = fileInput = document.createElement(\"input\");\r\n\r\n            function selectFiles(pickedFiles) {\r\n                for (var i = pickedFiles.length; i--;) {\r\n                    if (pickedFiles[i].size > maxFileSize) {\r\n                        pickedFiles.splice(i, 1);\r\n                    }\r\n                }\r\n                fileSelected(pickedFiles);\r\n            }\r\n\r\n            input.type = \"file\";\r\n            input.style.position = \"fixed\",\r\n                input.style.left = 0,\r\n                input.style.top = 0,\r\n                input.style.opacity = .001,\r\n                document.body.appendChild(input);\r\n\r\n            input.onchange = function(e) {\r\n                var entries = e.target.webkitEntries || e.target.entries;\r\n\r\n                if (entries && entries.length) {\r\n                    webentry.all(entries).then(function(files) {\r\n                        selectFiles(files);\r\n                    });\r\n                } else {\r\n                    selectFiles(Array.prototype.slice.call(e.target.files));\r\n                }\r\n                // reset to \"\", so selecting the same file next time still trigger the change handler\r\n                input.value = \"\";\r\n            };\r\n        }\r\n        fileInput.multiple = multiple;\r\n        fileInput.webkitdirectory = directory;\r\n        fileInput.click();\r\n    }\r\n\r\n    function upload(params) {\r\n        var xoptions = langx.mixin({\r\n            contentRange: null, //\r\n\r\n            // The parameter name for the file form data (the request argument name).\r\n            // If undefined or empty, the name property of the file input field is\r\n            // used, or \"files[]\" if the file input name property is also empty,\r\n            // can be a string or an array of strings:\r\n            paramName: undefined,\r\n            // By default, each file of a selection is uploaded using an individual\r\n            // request for XHR type uploads. Set to false to upload file\r\n            // selections in one request each:\r\n            singleFileUploads: true,\r\n            // To limit the number of files uploaded with one XHR request,\r\n            // set the following option to an integer greater than 0:\r\n            limitMultiFileUploads: undefined,\r\n            // The following option limits the number of files uploaded with one\r\n            // XHR request to keep the request size under or equal to the defined\r\n            // limit in bytes:\r\n            limitMultiFileUploadSize: undefined,\r\n            // Multipart file uploads add a number of bytes to each uploaded file,\r\n            // therefore the following option adds an overhead for each file used\r\n            // in the limitMultiFileUploadSize configuration:\r\n            limitMultiFileUploadSizeOverhead: 512,\r\n            // Set the following option to true to issue all file upload requests\r\n            // in a sequential order:\r\n            sequentialUploads: false,\r\n            // To limit the number of concurrent uploads,\r\n            // set the following option to an integer greater than 0:\r\n            limitConcurrentUploads: undefined,\r\n            // By default, XHR file uploads are sent as multipart/form-data.\r\n            // The iframe transport is always using multipart/form-data.\r\n            // Set to false to enable non-multipart XHR uploads:\r\n            multipart: true,\r\n            // To upload large files in smaller chunks, set the following option\r\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n            // or the browser does not support the required Blob API, files will\r\n            // be uploaded as a whole.\r\n            maxChunkSize: undefined,\r\n            // When a non-multipart upload or a chunked multipart upload has been\r\n            // aborted, this option can be used to resume the upload by setting\r\n            // it to the size of the already uploaded bytes. This option is most\r\n            // useful when modifying the options object inside of the \"add\" or\r\n            // \"send\" callbacks, as the options are cloned for each file upload.\r\n            uploadedBytes: undefined,\r\n            // By default, failed (abort or error) file uploads are removed from the\r\n            // global progress calculation. Set the following option to false to\r\n            // prevent recalculating the global progress data:\r\n            recalculateProgress: true,\r\n            // Interval in milliseconds to calculate and trigger progress events:\r\n            progressInterval: 100,\r\n            // Interval in milliseconds to calculate progress bitrate:\r\n            bitrateInterval: 500,\r\n            // By default, uploads are started automatically when adding files:\r\n            autoUpload: true,\r\n\r\n            // Error and info messages:\r\n            messages: {\r\n                uploadedBytes: 'Uploaded bytes exceed file size'\r\n            },\r\n\r\n            // Translation function, gets the message key to be translated\r\n            // and an object with context specific data as arguments:\r\n            i18n: function(message, context) {\r\n                message = this.messages[message] || message.toString();\r\n                if (context) {\r\n                    langx.each(context, function(key, value) {\r\n                        message = message.replace('{' + key + '}', value);\r\n                    });\r\n                }\r\n                return message;\r\n            },\r\n\r\n            // Additional form data to be sent along with the file uploads can be set\r\n            // using this option, which accepts an array of objects with name and\r\n            // value properties, a function returning such an array, a FormData\r\n            // object (for XHR file uploads), or a simple object.\r\n            // The form of the first fileInput is given as parameter to the function:\r\n            formData: function(form) {\r\n                return form.serializeArray();\r\n            },\r\n\r\n            // The add callback is invoked as soon as files are added to the fileupload\r\n            // widget (via file input selection, drag & drop, paste or add API call).\r\n            // If the singleFileUploads option is enabled, this callback will be\r\n            // called once for each file in the selection for XHR file uploads, else\r\n            // once for each file selection.\r\n            //\r\n            // The upload starts when the submit method is invoked on the data parameter.\r\n            // The data object contains a files property holding the added files\r\n            // and allows you to override plugin options as well as define ajax settings.\r\n            //\r\n            // Listeners for this callback can also be bound the following way:\r\n            // .bind('fileuploadadd', func);\r\n            //\r\n            // data.submit() returns a Promise object and allows to attach additional\r\n            // handlers using jQuery's Deferred callbacks:\r\n            // data.submit().done(func).fail(func).always(func);\r\n            add: function(e, data) {\r\n                if (e.isDefaultPrevented()) {\r\n                    return false;\r\n                }\r\n                if (data.autoUpload || (data.autoUpload !== false &&\r\n                        $(this).fileupload('option', 'autoUpload'))) {\r\n                    data.process().done(function() {\r\n                        data.submit();\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Other callbacks:\r\n\r\n            // Callback for the submit event of each file upload:\r\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\r\n\r\n            // Callback for the start of each file upload request:\r\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\r\n\r\n            // Callback for successful uploads:\r\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\r\n\r\n            // Callback for failed (abort or error) uploads:\r\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\r\n\r\n            // Callback for completed (success, abort or error) requests:\r\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\r\n\r\n            // Callback for upload progress events:\r\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\r\n\r\n            // Callback for global upload progress events:\r\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\r\n\r\n            // Callback for uploads start, equivalent to the global ajaxStart event:\r\n            // start: function (e) {}, // .bind('fileuploadstart', func);\r\n\r\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\r\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\r\n\r\n            // Callback for change events of the fileInput(s):\r\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\r\n\r\n            // Callback for paste events to the pasteZone(s):\r\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\r\n\r\n            // Callback for drop events of the dropZone(s):\r\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\r\n\r\n            // Callback for dragover events of the dropZone(s):\r\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\r\n\r\n            // Callback for the start of each chunk upload request:\r\n            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\r\n\r\n            // Callback for successful chunk uploads:\r\n            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\r\n\r\n            // Callback for failed (abort or error) chunk uploads:\r\n            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\r\n\r\n            // Callback for completed (success, abort or error) chunk upload requests:\r\n            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\r\n\r\n            // The plugin options are used as settings object for the ajax calls.\r\n            // The following are jQuery ajax settings required for the file uploads:\r\n            processData: false,\r\n            contentType: false,\r\n            cache: false\r\n        }, params);\r\n\r\n        var blobSlice = function() {\r\n                var slice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;\r\n                return slice.apply(this, arguments);\r\n            },\r\n            ajax = function(data) {\r\n                return langx.Xhr.request(data.url, data);\r\n            };\r\n\r\n        function initDataSettings(o) {\r\n            o.type = o.type || \"POST\";\r\n\r\n            if (!chunkedUpload(o, true)) {\r\n                if (!o.data) {\r\n                    initXHRData(o);\r\n                }\r\n                //initProgressListener(o);\r\n            }\r\n        }\r\n\r\n        function initXHRData(o) {\r\n            var that = this,\r\n                formData,\r\n                file = o.files[0],\r\n                // Ignore non-multipart setting if not supported:\r\n                multipart = o.multipart,\r\n                paramName = langx.type(o.paramName) === 'array' ?\r\n                o.paramName[0] : o.paramName;\r\n\r\n            o.headers = langx.mixin({}, o.headers);\r\n            if (o.contentRange) {\r\n                o.headers['Content-Range'] = o.contentRange;\r\n            }\r\n            if (!multipart) {\r\n                o.headers['Content-Disposition'] = 'attachment; filename=\"' +\r\n                    encodeURI(file.name) + '\"';\r\n                o.contentType = file.type || 'application/octet-stream';\r\n                o.data = o.blob || file;\r\n            } else {\r\n                formData = new FormData();\r\n                if (o.blob) {\r\n                    formData.append(paramName, o.blob, file.name);\r\n                } else {\r\n                    langx.each(o.files, function(index, file) {\r\n                        // This check allows the tests to run with\r\n                        // dummy objects:\r\n                        formData.append(\r\n                            (langx.type(o.paramName) === 'array' &&\r\n                                o.paramName[index]) || paramName,\r\n                            file,\r\n                            file.uploadName || file.name\r\n                        );\r\n                    });\r\n                }\r\n                o.data = formData;\r\n            }\r\n            // Blob reference is not needed anymore, free memory:\r\n            o.blob = null;\r\n        }\r\n\r\n        function getTotal(files) {\r\n            var total = 0;\r\n            langx.each(files, function(index, file) {\r\n                total += file.size || 1;\r\n            });\r\n            return total;\r\n        }\r\n\r\n        function getUploadedBytes(jqXHR) {\r\n            var range = jqXHR.getResponseHeader('Range'),\r\n                parts = range && range.split('-'),\r\n                upperBytesPos = parts && parts.length > 1 &&\r\n                parseInt(parts[1], 10);\r\n            return upperBytesPos && upperBytesPos + 1;\r\n        }\r\n\r\n        function initProgressObject(obj) {\r\n            var progress = {\r\n                loaded: 0,\r\n                total: 0,\r\n                bitrate: 0\r\n            };\r\n            if (obj._progress) {\r\n                langx.mixin(obj._progress, progress);\r\n            } else {\r\n                obj._progress = progress;\r\n            }\r\n        }\r\n\r\n        function BitrateTimer() {\r\n            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());\r\n            this.loaded = 0;\r\n            this.bitrate = 0;\r\n            this.getBitrate = function(now, loaded, interval) {\r\n                var timeDiff = now - this.timestamp;\r\n                if (!this.bitrate || !interval || timeDiff > interval) {\r\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\r\n                    this.loaded = loaded;\r\n                    this.timestamp = now;\r\n                }\r\n                return this.bitrate;\r\n            };\r\n        }\r\n\r\n        function chunkedUpload(options, testOnly) {\r\n            options.uploadedBytes = options.uploadedBytes || 0;\r\n            var that = this,\r\n                file = options.files[0],\r\n                fs = file.size,\r\n                ub = options.uploadedBytes,\r\n                mcs = options.maxChunkSize || fs,\r\n                slice = blobSlice,\r\n                dfd = new Deferred(),\r\n                promise = dfd.promise,\r\n                jqXHR,\r\n                upload;\r\n            if (!(slice && (ub || mcs < fs)) ||\r\n                options.data) {\r\n                return false;\r\n            }\r\n            if (testOnly) {\r\n                return true;\r\n            }\r\n            if (ub >= fs) {\r\n                file.error = options.i18n('uploadedBytes');\r\n                return this._getXHRPromise(\r\n                    false,\r\n                    options.context, [null, 'error', file.error]\r\n                );\r\n            }\r\n            // The chunk upload method:\r\n            upload = function() {\r\n                // Clone the options object for each chunk upload:\r\n                var o = langx.mixin({}, options),\r\n                    currentLoaded = o._progress.loaded;\r\n                o.blob = slice.call(\r\n                    file,\r\n                    ub,\r\n                    ub + mcs,\r\n                    file.type\r\n                );\r\n                // Store the current chunk size, as the blob itself\r\n                // will be dereferenced after data processing:\r\n                o.chunkSize = o.blob.size;\r\n                // Expose the chunk bytes position range:\r\n                o.contentRange = 'bytes ' + ub + '-' +\r\n                    (ub + o.chunkSize - 1) + '/' + fs;\r\n                // Process the upload data (the blob and potential form data):\r\n                initXHRData(o);\r\n                // Add progress listeners for this chunk upload:\r\n                //initProgressListener(o);\r\n                jqXHR = $.ajax(o).done(function(result, textStatus, jqXHR) {\r\n                        ub = getUploadedBytes(jqXHR) ||\r\n                            (ub + o.chunkSize);\r\n                        // Create a progress event if no final progress event\r\n                        // with loaded equaling total has been triggered\r\n                        // for this chunk:\r\n                        if (currentLoaded + o.chunkSize - o._progress.loaded) {\r\n                            dfd.progress({\r\n                                lengthComputable: true,\r\n                                loaded: ub - o.uploadedBytes,\r\n                                total: ub - o.uploadedBytes\r\n                            });\r\n                        }\r\n                        options.uploadedBytes = o.uploadedBytes = ub;\r\n                        o.result = result;\r\n                        o.textStatus = textStatus;\r\n                        o.jqXHR = jqXHR;\r\n                        //that._trigger('chunkdone', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        if (ub < fs) {\r\n                            // File upload not yet complete,\r\n                            // continue with the next chunk:\r\n                            upload();\r\n                        } else {\r\n                            dfd.resolveWith(\r\n                                o.context, [result, textStatus, jqXHR]\r\n                            );\r\n                        }\r\n                    })\r\n                    .fail(function(jqXHR, textStatus, errorThrown) {\r\n                        o.jqXHR = jqXHR;\r\n                        o.textStatus = textStatus;\r\n                        o.errorThrown = errorThrown;\r\n                        //that._trigger('chunkfail', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        dfd.rejectWith(\r\n                            o.context, [jqXHR, textStatus, errorThrown]\r\n                        );\r\n                    });\r\n            };\r\n            //this._enhancePromise(promise);\r\n            promise.abort = function() {\r\n                return jqXHR.abort();\r\n            };\r\n            upload();\r\n            return promise;\r\n        }\r\n\r\n        initDataSettings(xoptions);\r\n\r\n        xoptions._bitrateTimer = new BitrateTimer();\r\n\r\n        var jqXhr = chunkedUpload(xoptions) || ajax(xoptions);\r\n\r\n        jqXhr.options = xoptions;\r\n\r\n        return jqXhr;\r\n    }\r\n\r\n    var filer = function() {\r\n        return filer;\r\n    };\r\n\r\n    langx.mixin(filer, {\r\n        dropzone: dropzone,\r\n\r\n        pastezone: pastezone,\r\n\r\n        picker: picker,\r\n\r\n        select: select,\r\n\r\n        upload: upload,\r\n\r\n        readFile: function(file, params) {\r\n            params = params || {};\r\n            var d = new Deferred,\r\n                reader = new FileReader();\r\n\r\n            reader.onload = function(evt) {\r\n                d.resolve(evt.target.result);\r\n            };\r\n            reader.onerror = function(e) {\r\n                var code = e.target.error.code;\r\n                if (code === 2) {\r\n                    alert('please don\\'t open this page using protocol fill:///');\r\n                } else {\r\n                    alert('error code: ' + code);\r\n                }\r\n            };\r\n\r\n            if (params.asArrayBuffer) {\r\n                reader.readAsArrayBuffer(file);\r\n            } else if (params.asDataUrl) {\r\n                reader.readAsDataURL(file);\r\n            } else if (params.asText) {\r\n                reader.readAsText(file);\r\n            } else {\r\n                reader.readAsArrayBuffer(file);\r\n            }\r\n\r\n            return d.promise;\r\n        },\r\n\r\n        writeFile: function(data, name) {\r\n            if (window.navigator.msSaveBlob) {\r\n                if (langx.isString(data)) {\r\n                    data = dataURItoBlob(data);\r\n                }\r\n                window.navigator.msSaveBlob(data, name);\r\n            } else {\r\n                var a = document.createElement('a');\r\n                if (data instanceof Blob) {\r\n                    data = langx.URL.createObjectURL(data);\r\n                }\r\n                a.href = data;\r\n                a.setAttribute('download', name || 'noname');\r\n                a.dispatchEvent(new CustomEvent('click'));\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    return skylark.filer = filer;\r\n});"]}