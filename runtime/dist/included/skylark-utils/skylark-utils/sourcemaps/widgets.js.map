{"version":3,"sources":["widgets.js"],"names":["define","skylark","langx","noder","datax","styler","geom","eventer","query","velm","widget","defineWidgetClass","name","base","prototype","delegateEventSplitter","Widget","Array","slice","Evented","inherit","init","options","el","isHtmlNode","this","mixin","cid","uniqueId","_ensureElement","tagName","$","selector","$el","find","render","remove","_removeElement","unlistenTo","setElement","element","undelegateEvents","_setElement","delegateEvents","events","result","key","method","isFunction","match","delegate","proxy","eventName","listener","on","uid","off","undelegate","_createElement","attrs","createElement","id","className","_setAttributes","attributes","attr","i18n","message","context","messages","toString","each","value","replace"],"mappings":"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","file":"../widgets.js","sourcesContent":["define([\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./noder\",\r\n    \"./datax\",\r\n    \"./styler\",\r\n    \"./geom\",\r\n    \"./eventer\",\r\n    \"./query\",\r\n    \"./velm\"\r\n], function(skylark,langx,noder, datax, styler, geom, eventer,query,velm) {\r\n\t// Cached regex to split keys for `delegate`.\r\n\tvar delegateEventSplitter = /^(\\S+)\\s*(.*)$/,\r\n\t\tslice = Array.prototype.slice;\r\n\r\n\r\n\tfunction bridge( name, object ) {\r\n\t\tvar fullName = object.prototype.widgetFullName || name,\r\n\t\t\tfn = {};\r\n\r\n\t\tfunction _delegate (isQuery) {\r\n\r\n\t\t}\r\n\r\n\t\tfn[name] = function( options ) {\r\n\t\t\tvar isMethodCall = typeof options === \"string\";\r\n\t\t\tvar args = slice.call( arguments, 1 );\r\n\t\t\tvar returnValue = this;\r\n\r\n\t\t\tif ( isMethodCall ) {\r\n\r\n\t\t\t\t// If this is an empty collection, we need to have the instance method\r\n\t\t\t\t// return undefined instead of the jQuery instance\r\n\t\t\t\tif ( !this.length && options === \"instance\" ) {\r\n\t\t\t\t\treturnValue = undefined;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.each( function() {\r\n\t\t\t\t\t\tvar methodValue;\r\n\t\t\t\t\t\tvar instance = datax.data( this, fullName );\r\n\r\n\t\t\t\t\t\tif ( options === \"instance\" ) {\r\n\t\t\t\t\t\t\treturnValue = instance;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( !instance ) {\r\n\t\t\t\t\t\t\treturn $.error( \"cannot call methods on \" + name +\r\n\t\t\t\t\t\t\t\t\" prior to initialization; \" +\r\n\t\t\t\t\t\t\t\t\"attempted to call method '\" + options + \"'\" );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === \"_\" ) {\r\n\t\t\t\t\t\t\treturn $.error( \"no such method '\" + options + \"' for \" + name +\r\n\t\t\t\t\t\t\t\t\" widget instance\" );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmethodValue = instance[ options ].apply( instance, args );\r\n\r\n\t\t\t\t\t\tif ( methodValue !== instance && methodValue !== undefined ) {\r\n\t\t\t\t\t\t\treturnValue = methodValue && methodValue.jquery ?\r\n\t\t\t\t\t\t\t\treturnValue.pushStack( methodValue.get() ) :\r\n\t\t\t\t\t\t\t\tmethodValue;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Allow multiple hashes to be passed on init\r\n\t\t\t\tif ( args.length ) {\r\n\t\t\t\t\toptions = $.widget.extend.apply( null, [ options ].concat( args ) );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.each( function() {\r\n\t\t\t\t\tvar instance = datax.data( this, fullName );\r\n\t\t\t\t\tif ( instance ) {\r\n\t\t\t\t\t\tinstance.option( options || {} );\r\n\t\t\t\t\t\tif ( instance._init ) {\r\n\t\t\t\t\t\t\tinstance._init();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdatax.data( this, fullName, new object( options, this ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\r\n\t\t\treturn returnValue;\r\n\t\t};\r\n\t};\r\n\r\n\tfunction widget() {\r\n\t    return widget;\r\n\t}\r\n\r\n\tvar Widget = langx.Evented.inherit({\r\n\t    init :function(options,el) {\r\n\t    \t//for supporting init(el,options)\r\n\t        if (langx.isHtmlNode(options)) {\r\n\t        \tvar _t = el,\r\n\t        \t\toptions = el;\r\n\t            el = options;\r\n\t        }\r\n\t        if (el) {\r\n\t        \tthis.el = el;\r\n\t    \t}\r\n\t        if (options) {\r\n\t            langx.mixin(this,options);\r\n\t        }\r\n\t        if (!this.cid) {\r\n\t            this.cid = langx.uniqueId('w');\r\n\t        }\r\n\t        this._ensureElement();\r\n\t    },\r\n\r\n\t    // The default `tagName` of a View's element is `\"div\"`.\r\n\t    tagName: 'div',\r\n\r\n\t    // jQuery delegate for element lookup, scoped to DOM elements within the\r\n\t    // current view. This should be preferred to global lookups where possible.\r\n\t    $: function(selector) {\r\n\t      return this.$el.find(selector);\r\n\t    },\r\n\r\n\t    // **render** is the core function that your view should override, in order\r\n\t    // to populate its element (`this.el`), with the appropriate HTML. The\r\n\t    // convention is for **render** to always return `this`.\r\n\t    render: function() {\r\n\t      return this;\r\n\t    },\r\n\r\n\t    // Remove this view by taking the element out of the DOM, and removing any\r\n\t    // applicable Backbone.Events listeners.\r\n\t    remove: function() {\r\n\t      this._removeElement();\r\n\t      this.unlistenTo();\r\n\t      return this;\r\n\t    },\r\n\r\n\t    // Remove this view's element from the document and all event listeners\r\n\t    // attached to it. Exposed for subclasses using an alternative DOM\r\n\t    // manipulation API.\r\n\t    _removeElement: function() {\r\n\t      this.$el.remove();\r\n\t    },\r\n\r\n\t    // Change the view's element (`this.el` property) and re-delegate the\r\n\t    // view's events on the new element.\r\n\t    setElement: function(element) {\r\n\t      this.undelegateEvents();\r\n\t      this._setElement(element);\r\n\t      this.delegateEvents();\r\n\t      return this;\r\n\t    },\r\n\r\n\t    // Creates the `this.el` and `this.$el` references for this view using the\r\n\t    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\r\n\t    // context or an element. Subclasses can override this to utilize an\r\n\t    // alternative DOM manipulation API and are only required to set the\r\n\t    // `this.el` property.\r\n\t    _setElement: function(el) {\r\n\t      this.$el = widget.$(el);\r\n\t      this.el = this.$el[0];\r\n\t    },\r\n\r\n\t    // Set callbacks, where `this.events` is a hash of\r\n\t    //\r\n\t    // *{\"event selector\": \"callback\"}*\r\n\t    //\r\n\t    //     {\r\n\t    //       'mousedown .title':  'edit',\r\n\t    //       'click .button':     'save',\r\n\t    //       'click .open':       function(e) { ... }\r\n\t    //     }\r\n\t    //\r\n\t    // pairs. Callbacks will be bound to the view, with `this` set properly.\r\n\t    // Uses event delegation for efficiency.\r\n\t    // Omitting the selector binds the event to `this.el`.\r\n\t    delegateEvents: function(events) {\r\n\t      events || (events = langx.result(this, 'events'));\r\n\t      if (!events) return this;\r\n\t      this.undelegateEvents();\r\n\t      for (var key in events) {\r\n\t        var method = events[key];\r\n\t        if (!langx.isFunction(method)) method = this[method];\r\n\t        if (!method) continue;\r\n\t        var match = key.match(delegateEventSplitter);\r\n\t        this.delegate(match[1], match[2], langx.proxy(method, this));\r\n\t      }\r\n\t      return this;\r\n\t    },\r\n\r\n\t    // Add a single event listener to the view's element (or a child element\r\n\t    // using `selector`). This only works for delegate-able events: not `focus`,\r\n\t    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\r\n\t    delegate: function(eventName, selector, listener) {\r\n\t      this.$el.on(eventName + '.delegateEvents' + this.uid, selector, listener);\r\n\t      return this;\r\n\t    },\r\n\r\n\t    // Clears all callbacks previously bound to the view by `delegateEvents`.\r\n\t    // You usually don't need to use this, but may wish to if you have multiple\r\n\t    // Backbone views attached to the same DOM element.\r\n\t    undelegateEvents: function() {\r\n\t      if (this.$el) this.$el.off('.delegateEvents' + this.uid);\r\n\t      return this;\r\n\t    },\r\n\r\n\t    // A finer-grained `undelegateEvents` for removing a single delegated event.\r\n\t    // `selector` and `listener` are both optional.\r\n\t    undelegate: function(eventName, selector, listener) {\r\n\t      this.$el.off(eventName + '.delegateEvents' + this.uid, selector, listener);\r\n\t      return this;\r\n\t    },\r\n\r\n\t    // Produces a DOM element to be assigned to your view. Exposed for\r\n\t    // subclasses using an alternative DOM manipulation API.\r\n\t    _createElement: function(tagName,attrs) {\r\n\t      return noder.createElement(tagName,attrs);\r\n\t    },\r\n\r\n\t    // Ensure that the View has a DOM element to render into.\r\n\t    // If `this.el` is a string, pass it through `$()`, take the first\r\n\t    // matching element, and re-assign it to `el`. Otherwise, create\r\n\t    // an element from the `id`, `className` and `tagName` properties.\r\n\t    _ensureElement: function() {\r\n\t      if (!this.el) {\r\n\t        var attrs = langx.mixin({}, langx.result(this, 'attributes'));\r\n\t        if (this.id) attrs.id = langx.result(this, 'id');\r\n\t        if (this.className) attrs['class'] = langx.result(this, 'className');\r\n\t        this.setElement(this._createElement(langx.result(this, 'tagName'),attrs));\r\n\t        this._setAttributes(attrs);\r\n\t      } else {\r\n\t        this.setElement(langx.result(this, 'el'));\r\n\t      }\r\n\t    },\r\n\r\n\t    // Set attributes from a hash on this view's element.  Exposed for\r\n\t    // subclasses using an alternative DOM manipulation API.\r\n\t    _setAttributes: function(attributes) {\r\n\t      this.$el.attr(attributes);\r\n\t    },\r\n\r\n\t    // Translation function, gets the message key to be translated\r\n\t    // and an object with context specific data as arguments:\r\n\t    i18n: function (message, context) {\r\n\t        message = (this.messages && this.messages[message]) || message.toString();\r\n\t        if (context) {\r\n\t            langx.each(context, function (key, value) {\r\n\t                message = message.replace('{' + key + '}', value);\r\n\t            });\r\n\t        }\r\n\t        return message;\r\n\t    },\r\n\r\n\t\t});\r\n\r\n\tfunction defineWidgetClass(name,base,prototype) {\r\n\r\n\t};\r\n\r\n\tlangx.mixin(widget, {\r\n\t\t$ : query,\r\n\r\n\t\tdefine : defineWidgetClass,\r\n\t\tWidget : Widget\r\n\t});\r\n\r\n\r\n\treturn skylark.widget = widget;\r\n});\r\n"]}