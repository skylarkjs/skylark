{"version":3,"sources":["popup.js"],"names":["define","skylark","langx","noder","styles","geom","eventer","popup","Array","prototype","some","mixin"],"mappings":";;;;;;;AAAAA,QACI,YACA,UACA,UACA,WACA,SACA,aACD,SAASC,EAAQC,EAAMC,EAAMC,EAAOC,EAAKC,GAgMxC,QAASC,KACL,MAAOA,GA/LAC,MAAMC,UAAUC,IAuM3B,OALAR,GAAMS,MAAMJ,MAKLN,EAAQM,MAAQA","file":"../popup.js","sourcesContent":["define([\n    \"./skylark\",\n    \"./langx\",\n    \"./noder\",\n    \"./styles\",\n    \"./geom\",\n    \"./eventer\"\n], function(skylark,langx,noder,styles,geom,eventer) {\n\n    var some = Array.prototype.some,\n        stack = [],\n        beginZIndex = 10000,\n        idGen = 1;\n\n\n\n    function close(elm,params){\n        // summary:\n        //      Close specified popup and any popups that it parented.\n        //      If no popup is specified, closes all popups.\n\n        var idx = -1;\n        for (var i=stack.length-1;i>-1;i--) {\n            if (stack[i].elm == elm) {\n                idx = i;\n                break;\n            }\n        }\n        while (stack.length){\n            var top = stack.pop(),\n                widget = top.widget,\n                onClose = top.onClose;\n\n            if(widget.onClose){\n                // TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here).\n                // Actually, StackContainer also calls onClose(), but to mean that the pane is being deleted\n                // (i.e. that the TabContainer's tab's [x] icon was clicked)\n                widget.onClose();\n            }\n\n            var h;\n            while(h = top.handlers.pop()){\n                h.remove();\n            }\n\n            // Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.\n            if(widget && widget.domNode){\n                this.hide(widget);\n            }\n\n            if(onClose){\n                onClose();\n            }\n            if (top == elm) {\n                break;\n            }\n        }\n\n        if(stack.length == 0 && this._aroundMoveListener){\n            clearTimeout(this._aroundMoveListener);\n            this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;\n        }\n    }\n\n    function open(elm,args) {\n\n        while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length - 1].widget.domNode))){\n            this.close(stack[stack.length - 1].widget);\n        }\n\n        var stack = this._stack,\n            widget = args.popup,\n            node = widget.domNode,\n            orient = args.orient || [\"below\", \"below-alt\", \"above\", \"above-alt\"],\n            ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(widget.ownerDocument),\n            around = args.around,\n            id = (args.around && args.around.id) ? (args.around.id + \"_dropdown\") : (\"popup_\" + this._idGen++);\n\n        // If we are opening a new popup that isn't a child of a currently opened popup, then\n        // close currently opened popup(s).   This should happen automatically when the old popups\n        // gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].\n        while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length - 1].widget.domNode))){\n            this.close(stack[stack.length - 1].widget);\n        }\n\n        // Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep\n        // off screen) so we can do sizing calculations.\n        var wrapper = this.moveOffScreen(widget);\n\n        if(widget.startup && !widget._started){\n            widget.startup(); // this has to be done after being added to the DOM\n        }\n\n        // Limit height to space available in viewport either above or below aroundNode (whichever side has more\n        // room), adding scrollbar if necessary. Can't add scrollbar to widget because it may be a <table> (ex:\n        // dijit/Menu), so add to wrapper, and then move popup's border to wrapper so scroll bar inside border.\n        var maxHeight, popupSize = domGeometry.position(node);\n        if(\"maxHeight\" in args && args.maxHeight != -1){\n            maxHeight = args.maxHeight || Infinity; // map 0 --> infinity for back-compat of _HasDropDown.maxHeight\n        }else{\n            var viewport = Viewport.getEffectiveBox(this.ownerDocument),\n                aroundPos = around ? domGeometry.position(around, false) : {y: args.y - (args.padding||0), h: (args.padding||0) * 2};\n            maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));\n        }\n        if(popupSize.h > maxHeight){\n            // Get style of popup's border.  Unfortunately domStyle.get(node, \"border\") doesn't work on FF or IE,\n            // and domStyle.get(node, \"borderColor\") etc. doesn't work on FF, so need to use fully qualified names.\n            var cs = domStyle.getComputedStyle(node),\n                borderStyle = cs.borderLeftWidth + \" \" + cs.borderLeftStyle + \" \" + cs.borderLeftColor;\n            domStyle.set(wrapper, {\n                overflowY: \"scroll\",\n                height: maxHeight + \"px\",\n                border: borderStyle // so scrollbar is inside border\n            });\n            node._originalStyle = node.style.cssText;\n            node.style.border = \"none\";\n        }\n\n        domAttr.set(wrapper, {\n            id: id,\n            style: {\n                zIndex: this._beginZIndex + stack.length\n            },\n            \"class\": \"dijitPopup \" + (widget.baseClass || widget[\"class\"] || \"\").split(\" \")[0] + \"Popup\",\n            dijitPopupParent: args.parent ? args.parent.id : \"\"\n        });\n\n        if(stack.length == 0 && around){\n            // First element on stack. Save position of aroundNode and setup listener for changes to that position.\n            this._firstAroundNode = around;\n            this._firstAroundPosition = domGeometry.position(around, true);\n            this._aroundMoveListener = setTimeout(lang.hitch(this, \"_repositionAll\"), 50);\n        }\n\n        if(has(\"config-bgIframe\") && !widget.bgIframe){\n            // setting widget.bgIframe triggers cleanup in _WidgetBase.destroyRendering()\n            widget.bgIframe = new BackgroundIframe(wrapper);\n        }\n\n        // position the wrapper node and make it visible\n        var layoutFunc = widget.orient ? lang.hitch(widget, \"orient\") : null,\n            best = around ?\n                place.around(wrapper, around, orient, ltr, layoutFunc) :\n                place.at(wrapper, args, orient == 'R' ? ['TR', 'BR', 'TL', 'BL'] : ['TL', 'BL', 'TR', 'BR'], args.padding,\n                    layoutFunc);\n\n        wrapper.style.visibility = \"visible\";\n        node.style.visibility = \"visible\";  // counteract effects from _HasDropDown\n\n        var handlers = [];\n\n        // provide default escape and tab key handling\n        // (this will work for any widget, not just menu)\n        handlers.push(on(wrapper, \"keydown\", lang.hitch(this, function(evt){\n            if(evt.keyCode == keys.ESCAPE && args.onCancel){\n                evt.stopPropagation();\n                evt.preventDefault();\n                args.onCancel();\n            }else if(evt.keyCode == keys.TAB){\n                evt.stopPropagation();\n                evt.preventDefault();\n                var topPopup = this.getTopPopup();\n                if(topPopup && topPopup.onCancel){\n                    topPopup.onCancel();\n                }\n            }\n        })));\n\n        // watch for cancel/execute events on the popup and notify the caller\n        // (for a menu, \"execute\" means clicking an item)\n        if(widget.onCancel && args.onCancel){\n            handlers.push(widget.on(\"cancel\", args.onCancel));\n        }\n\n        handlers.push(widget.on(widget.onExecute ? \"execute\" : \"change\", lang.hitch(this, function(){\n            var topPopup = this.getTopPopup();\n            if(topPopup && topPopup.onExecute){\n                topPopup.onExecute();\n            }\n        })));\n\n        stack.push({\n            widget: widget,\n            wrapper: wrapper,\n            parent: args.parent,\n            onExecute: args.onExecute,\n            onCancel: args.onCancel,\n            onClose: args.onClose,\n            handlers: handlers\n        });\n\n        if(widget.onOpen){\n            // TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)\n            widget.onOpen(best);\n        }\n\n        return best;\n    }\n\n    function popup() {\n        return popup;\n    }\n\n    langx.mixin(popup, {\n\n    });\n\n\n    return skylark.popup = popup;\n});\n"]}