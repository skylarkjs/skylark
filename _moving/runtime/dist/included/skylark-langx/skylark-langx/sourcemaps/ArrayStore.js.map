{"version":3,"sources":["ArrayStore.js"],"names":["define","klass","SimpleQueryEngine","query","options","filter","arr","callback","thisObject","value","i","l","length","out","split","cache","buildFn","call","push","execute","array","results","sortSet","sort","a","b","aValue","attribute","bValue","valueOf","descending","start","count","total","slice","Infinity","Error","queryObject","object","key","required","test","this","matches","QueryResults","addIterativeMethod","method","args","arguments","result","Deferred","when","Array","prototype","apply","isPromise","then","Object","delegate","ArrayStore","klassName","queryEngine","idProperty","get","id","data","index","getIdentity","put","Math","random","overwrite","add","remove","splice","setData","items","identifier","init"],"mappings":"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","file":"../ArrayStore.js","sourcesContent":["define([\r\n    \"./klass\"\r\n],function(klass){\r\n    var SimpleQueryEngine = function(query, options){\r\n        // summary:\r\n        //      Simple query engine that matches using filter functions, named filter\r\n        //      functions or objects by name-value on a query object hash\r\n        //\r\n        // description:\r\n        //      The SimpleQueryEngine provides a way of getting a QueryResults through\r\n        //      the use of a simple object hash as a filter.  The hash will be used to\r\n        //      match properties on data objects with the corresponding value given. In\r\n        //      other words, only exact matches will be returned.\r\n        //\r\n        //      This function can be used as a template for more complex query engines;\r\n        //      for example, an engine can be created that accepts an object hash that\r\n        //      contains filtering functions, or a string that gets evaluated, etc.\r\n        //\r\n        //      When creating a new dojo.store, simply set the store's queryEngine\r\n        //      field as a reference to this function.\r\n        //\r\n        // query: Object\r\n        //      An object hash with fields that may match fields of items in the store.\r\n        //      Values in the hash will be compared by normal == operator, but regular expressions\r\n        //      or any object that provides a test() method are also supported and can be\r\n        //      used to match strings by more complex expressions\r\n        //      (and then the regex's or object's test() method will be used to match values).\r\n        //\r\n        // options: dojo/store/api/Store.QueryOptions?\r\n        //      An object that contains optional information such as sort, start, and count.\r\n        //\r\n        // returns: Function\r\n        //      A function that caches the passed query under the field \"matches\".  See any\r\n        //      of the \"query\" methods on dojo.stores.\r\n        //\r\n        // example:\r\n        //      Define a store with a reference to this engine, and set up a query method.\r\n        //\r\n        //  |   var myStore = function(options){\r\n        //  |       //  ...more properties here\r\n        //  |       this.queryEngine = SimpleQueryEngine;\r\n        //  |       //  define our query method\r\n        //  |       this.query = function(query, options){\r\n        //  |           return QueryResults(this.queryEngine(query, options)(this.data));\r\n        //  |       };\r\n        //  |   };\r\n\r\n        // create our matching query function\r\n        switch(typeof query){\r\n            default:\r\n                throw new Error(\"Can not query with a \" + typeof query);\r\n            case \"object\": case \"undefined\":\r\n                var queryObject = query;\r\n                query = function(object){\r\n                    for(var key in queryObject){\r\n                        var required = queryObject[key];\r\n                        if(required && required.test){\r\n                            // an object can provide a test method, which makes it work with regex\r\n                            if(!required.test(object[key], object)){\r\n                                return false;\r\n                            }\r\n                        }else if(required != object[key]){\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                };\r\n                break;\r\n            case \"string\":\r\n                // named query\r\n                if(!this[query]){\r\n                    throw new Error(\"No filter function \" + query + \" was found in store\");\r\n                }\r\n                query = this[query];\r\n                // fall through\r\n            case \"function\":\r\n                // fall through\r\n        }\r\n        \r\n        function filter(arr, callback, thisObject){\r\n            // summary:\r\n            //      Returns a new Array with those items from arr that match the\r\n            //      condition implemented by callback.\r\n            // arr: Array\r\n            //      the array to iterate over.\r\n            // callback: Function|String\r\n            //      a function that is invoked with three arguments (item,\r\n            //      index, array). The return of this function is expected to\r\n            //      be a boolean which determines whether the passed-in item\r\n            //      will be included in the returned array.\r\n            // thisObject: Object?\r\n            //      may be used to scope the call to callback\r\n            // returns: Array\r\n            // description:\r\n            //      This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\r\n            //      run over sparse arrays, this implementation passes the \"holes\" in the sparse array to\r\n            //      the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\r\n            //      For more details, see:\r\n            //      https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\r\n            // example:\r\n            //  | // returns [2, 3, 4]\r\n            //  | array.filter([1, 2, 3, 4], function(item){ return item>1; });\r\n\r\n            // TODO: do we need \"Ctr\" here like in map()?\r\n            var i = 0, l = arr && arr.length || 0, out = [], value;\r\n            if(l && typeof arr == \"string\") arr = arr.split(\"\");\r\n            if(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\r\n            if(thisObject){\r\n                for(; i < l; ++i){\r\n                    value = arr[i];\r\n                    if(callback.call(thisObject, value, i, arr)){\r\n                        out.push(value);\r\n                    }\r\n                }\r\n            }else{\r\n                for(; i < l; ++i){\r\n                    value = arr[i];\r\n                    if(callback(value, i, arr)){\r\n                        out.push(value);\r\n                    }\r\n                }\r\n            }\r\n            return out; // Array\r\n        }\r\n\r\n        function execute(array){\r\n            // execute the whole query, first we filter\r\n            var results = filter(array, query);\r\n            // next we sort\r\n            var sortSet = options && options.sort;\r\n            if(sortSet){\r\n                results.sort(typeof sortSet == \"function\" ? sortSet : function(a, b){\r\n                    for(var sort, i=0; sort = sortSet[i]; i++){\r\n                        var aValue = a[sort.attribute];\r\n                        var bValue = b[sort.attribute];\r\n                        // valueOf enables proper comparison of dates\r\n                        aValue = aValue != null ? aValue.valueOf() : aValue;\r\n                        bValue = bValue != null ? bValue.valueOf() : bValue;\r\n                        if (aValue != bValue){\r\n                            // modified by lwf 2016/07/09\r\n                            //return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;\r\n                            return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;\r\n                        }\r\n                    }\r\n                    return 0;\r\n                });\r\n            }\r\n            // now we paginate\r\n            if(options && (options.start || options.count)){\r\n                var total = results.length;\r\n                results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));\r\n                results.total = total;\r\n            }\r\n            return results;\r\n        }\r\n        execute.matches = query;\r\n        return execute;\r\n    };\r\n\r\n    var QueryResults = function(results){\r\n        // summary:\r\n        //      A function that wraps the results of a store query with additional\r\n        //      methods.\r\n        // description:\r\n        //      QueryResults is a basic wrapper that allows for array-like iteration\r\n        //      over any kind of returned data from a query.  While the simplest store\r\n        //      will return a plain array of data, other stores may return deferreds or\r\n        //      promises; this wrapper makes sure that *all* results can be treated\r\n        //      the same.\r\n        //\r\n        //      Additional methods include `forEach`, `filter` and `map`.\r\n        // results: Array|dojo/promise/Promise\r\n        //      The result set as an array, or a promise for an array.\r\n        // returns:\r\n        //      An array-like object that can be used for iterating over.\r\n        // example:\r\n        //      Query a store and iterate over the results.\r\n        //\r\n        //  |   store.query({ prime: true }).forEach(function(item){\r\n        //  |       //  do something\r\n        //  |   });\r\n\r\n        if(!results){\r\n            return results;\r\n        }\r\n\r\n        var isPromise = !!results.then;\r\n        // if it is a promise it may be frozen\r\n        if(isPromise){\r\n            results = Object.delegate(results);\r\n        }\r\n        function addIterativeMethod(method){\r\n            // Always add the iterative methods so a QueryResults is\r\n            // returned whether the environment is ES3 or ES5\r\n            results[method] = function(){\r\n                var args = arguments;\r\n                var result = Deferred.when(results, function(results){\r\n                    //Array.prototype.unshift.call(args, results);\r\n                    return QueryResults(Array.prototype[method].apply(results, args));\r\n                });\r\n                // forEach should only return the result of when()\r\n                // when we're wrapping a promise\r\n                if(method !== \"forEach\" || isPromise){\r\n                    return result;\r\n                }\r\n            };\r\n        }\r\n\r\n        addIterativeMethod(\"forEach\");\r\n        addIterativeMethod(\"filter\");\r\n        addIterativeMethod(\"map\");\r\n        if(results.total == null){\r\n            results.total = Deferred.when(results, function(results){\r\n                return results.length;\r\n            });\r\n        }\r\n        return results; // Object\r\n    };\r\n\r\n    var ArrayStore = klass({\r\n        \"klassName\": \"ArrayStore\",\r\n\r\n        \"queryEngine\": SimpleQueryEngine,\r\n        \r\n        \"idProperty\": \"id\",\r\n\r\n\r\n        get: function(id){\r\n            // summary:\r\n            //      Retrieves an object by its identity\r\n            // id: Number\r\n            //      The identity to use to lookup the object\r\n            // returns: Object\r\n            //      The object in the store that matches the given id.\r\n            return this.data[this.index[id]];\r\n        },\r\n\r\n        getIdentity: function(object){\r\n            return object[this.idProperty];\r\n        },\r\n\r\n        put: function(object, options){\r\n            var data = this.data,\r\n                index = this.index,\r\n                idProperty = this.idProperty;\r\n            var id = object[idProperty] = (options && \"id\" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();\r\n            if(id in index){\r\n                // object exists\r\n                if(options && options.overwrite === false){\r\n                    throw new Error(\"Object already exists\");\r\n                }\r\n                // replace the entry in data\r\n                data[index[id]] = object;\r\n            }else{\r\n                // add the new object\r\n                index[id] = data.push(object) - 1;\r\n            }\r\n            return id;\r\n        },\r\n\r\n        add: function(object, options){\r\n            (options = options || {}).overwrite = false;\r\n            // call put with overwrite being false\r\n            return this.put(object, options);\r\n        },\r\n\r\n        remove: function(id){\r\n            // summary:\r\n            //      Deletes an object by its identity\r\n            // id: Number\r\n            //      The identity to use to delete the object\r\n            // returns: Boolean\r\n            //      Returns true if an object was removed, falsy (undefined) if no object matched the id\r\n            var index = this.index;\r\n            var data = this.data;\r\n            if(id in index){\r\n                data.splice(index[id], 1);\r\n                // now we have to reindex\r\n                this.setData(data);\r\n                return true;\r\n            }\r\n        },\r\n        query: function(query, options){\r\n            // summary:\r\n            //      Queries the store for objects.\r\n            // query: Object\r\n            //      The query to use for retrieving objects from the store.\r\n            // options: dojo/store/api/Store.QueryOptions?\r\n            //      The optional arguments to apply to the resultset.\r\n            // returns: dojo/store/api/Store.QueryResults\r\n            //      The results of the query, extended with iterative methods.\r\n            //\r\n            // example:\r\n            //      Given the following store:\r\n            //\r\n            //  |   var store = new Memory({\r\n            //  |       data: [\r\n            //  |           {id: 1, name: \"one\", prime: false },\r\n            //  |           {id: 2, name: \"two\", even: true, prime: true},\r\n            //  |           {id: 3, name: \"three\", prime: true},\r\n            //  |           {id: 4, name: \"four\", even: true, prime: false},\r\n            //  |           {id: 5, name: \"five\", prime: true}\r\n            //  |       ]\r\n            //  |   });\r\n            //\r\n            //  ...find all items where \"prime\" is true:\r\n            //\r\n            //  |   var results = store.query({ prime: true });\r\n            //\r\n            //  ...or find all items where \"even\" is true:\r\n            //\r\n            //  |   var results = store.query({ even: true });\r\n            return QueryResults(this.queryEngine(query, options)(this.data));\r\n        },\r\n\r\n        setData: function(data){\r\n            // summary:\r\n            //      Sets the given data as the source for this store, and indexes it\r\n            // data: Object[]\r\n            //      An array of objects to use as the source of data.\r\n            if(data.items){\r\n                // just for convenience with the data format IFRS expects\r\n                this.idProperty = data.identifier || this.idProperty;\r\n                data = this.data = data.items;\r\n            }else{\r\n                this.data = data;\r\n            }\r\n            this.index = {};\r\n            for(var i = 0, l = data.length; i < l; i++){\r\n                this.index[data[i][this.idProperty]] = i;\r\n            }\r\n        },\r\n\r\n        init: function(options) {\r\n            for(var i in options){\r\n                this[i] = options[i];\r\n            }\r\n            this.setData(this.data || []);\r\n        }\r\n\r\n    });\r\n\r\n\treturn ArrayStore;\r\n});"]}