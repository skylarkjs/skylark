{"version":3,"sources":["aspect.js"],"names":["define","advise","dispatcher","type","advice","receiveArguments","signal","previous","around","advised","this","arguments","remove","target","args","apply","next","id","nextId","aspect","methodName","existing","executionId","before","results","after","newResults","undefined","call"],"mappings":";;;;;;;AAAAA,UACE,WAGE,QAASC,GAAOC,EAAYC,EAAMC,EAAQC,GACtC,GAEIC,GAFAC,EAAWL,EAAWC,GACtBK,EAAiB,UAARL,CAEb,IAAGK,EAAO,CACN,GAAIC,GAAUL,EAAO,WACjB,MAAOG,GAASH,OAAOM,KAAMC,YAEjCL,IACIM,OAAQ,WACDH,IACCA,EAAUP,EAAaE,EAAS,OAGxCA,OAAQ,SAASS,EAAQC,GACrB,MAAOL,GACHA,EAAQM,MAAMF,EAAQC,GACtBP,EAASH,OAAOS,EAAQC,SAKpCR,IACIM,OAAQ,WACJ,GAAGN,EAAOF,OAAO,CACb,GAAIG,GAAWD,EAAOC,SAClBS,EAAOV,EAAOU,IACdA,IAAST,GAGNA,EACCA,EAASS,KAAOA,EAEhBd,EAAWC,GAAQa,EAEpBA,IACCA,EAAKT,SAAWA,UARbL,GAAWC,GAatBD,EAAaE,EAASE,EAAOF,OAAS,OAG9Ca,GAAIC,IACJd,OAAQA,EACRC,iBAAkBA,EAG1B,IAAGE,IAAaC,EACZ,GAAW,SAARL,EAAgB,CAGf,KAAMI,EAASS,OAAST,EAAWA,EAASS,QAC5CT,EAASS,KAAOV,EAChBA,EAAOC,SAAWA,MACL,UAARJ,IAELD,EAAWC,GAAQG,EACnBA,EAAOU,KAAOT,EACdA,EAASA,SAAWD,OAIxBJ,GAAWC,GAAQG,CAEvB,OAAOA,GAEX,QAASa,GAAOhB,GACZ,MAAO,UAASU,EAAQO,EAAYhB,EAAQC,GACxC,GAAmCH,GAA/BmB,EAAWR,EAAOO,EAClBC,IAAYA,EAASR,QAAUA,IAE/BA,EAAOO,GAAclB,EAAa,WAK9B,IAJA,GAAIoB,GAAcJ,EAEdJ,EAAOH,UACPY,EAASrB,EAAWqB,OAClBA,GACFT,EAAOS,EAAOnB,OAAOW,MAAML,KAAMI,IAASA,EAC1CS,EAASA,EAAOP,IAGpB,IAAGd,EAAWM,OACV,GAAIgB,GAAUtB,EAAWM,OAAOJ,OAAOM,KAAMI,EAIjD,KADA,GAAIW,GAAQvB,EAAWuB,MACjBA,GAASA,EAAMR,GAAKK,GAAY,CAClC,GAAGG,EAAMpB,iBAAiB,CACtB,GAAIqB,GAAaD,EAAMrB,OAAOW,MAAML,KAAMI,EAE1CU,GAAUE,IAAeC,EAAYH,EAAUE,MAE/CF,GAAUC,EAAMrB,OAAOwB,KAAKlB,KAAMc,EAASV,EAE/CW,GAAQA,EAAMT,KAElB,MAAOQ,IAERH,IACCnB,EAAWM,QAAUJ,OAAQ,SAASS,EAAQC,GAC1C,MAAOO,GAASN,MAAMF,EAAQC,MAGtCZ,EAAWW,OAASA,EAExB,IAAIW,GAAUvB,EAAQC,GAAcmB,EAAWlB,EAAMC,EAAQC,EAE7D,OADAD,GAAS,KACFoB,GA9GjB,GAAIG,GAAWT,EAAS,CAkHtB,QACIO,MAAON,EAAO,SAEdX,OAAQW,EAAO,UAEfI,OAAQJ,EAAO","file":"../aspect.js","sourcesContent":["define([\r\n],function(){\r\n\r\n  var undefined, nextId = 0;\r\n    function advise(dispatcher, type, advice, receiveArguments){\r\n        var previous = dispatcher[type];\r\n        var around = type == \"around\";\r\n        var signal;\r\n        if(around){\r\n            var advised = advice(function(){\r\n                return previous.advice(this, arguments);\r\n            });\r\n            signal = {\r\n                remove: function(){\r\n                    if(advised){\r\n                        advised = dispatcher = advice = null;\r\n                    }\r\n                },\r\n                advice: function(target, args){\r\n                    return advised ?\r\n                        advised.apply(target, args) :  // called the advised function\r\n                        previous.advice(target, args); // cancelled, skip to next one\r\n                }\r\n            };\r\n        }else{\r\n            // create the remove handler\r\n            signal = {\r\n                remove: function(){\r\n                    if(signal.advice){\r\n                        var previous = signal.previous;\r\n                        var next = signal.next;\r\n                        if(!next && !previous){\r\n                            delete dispatcher[type];\r\n                        }else{\r\n                            if(previous){\r\n                                previous.next = next;\r\n                            }else{\r\n                                dispatcher[type] = next;\r\n                            }\r\n                            if(next){\r\n                                next.previous = previous;\r\n                            }\r\n                        }\r\n\r\n                        // remove the advice to signal that this signal has been removed\r\n                        dispatcher = advice = signal.advice = null;\r\n                    }\r\n                },\r\n                id: nextId++,\r\n                advice: advice,\r\n                receiveArguments: receiveArguments\r\n            };\r\n        }\r\n        if(previous && !around){\r\n            if(type == \"after\"){\r\n                // add the listener to the end of the list\r\n                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\r\n                while(previous.next && (previous = previous.next)){}\r\n                previous.next = signal;\r\n                signal.previous = previous;\r\n            }else if(type == \"before\"){\r\n                // add to beginning\r\n                dispatcher[type] = signal;\r\n                signal.next = previous;\r\n                previous.previous = signal;\r\n            }\r\n        }else{\r\n            // around or first one just replaces\r\n            dispatcher[type] = signal;\r\n        }\r\n        return signal;\r\n    }\r\n    function aspect(type){\r\n        return function(target, methodName, advice, receiveArguments){\r\n            var existing = target[methodName], dispatcher;\r\n            if(!existing || existing.target != target){\r\n                // no dispatcher in place\r\n                target[methodName] = dispatcher = function(){\r\n                    var executionId = nextId;\r\n                    // before advice\r\n                    var args = arguments;\r\n                    var before = dispatcher.before;\r\n                    while(before){\r\n                        args = before.advice.apply(this, args) || args;\r\n                        before = before.next;\r\n                    }\r\n                    // around advice\r\n                    if(dispatcher.around){\r\n                        var results = dispatcher.around.advice(this, args);\r\n                    }\r\n                    // after advice\r\n                    var after = dispatcher.after;\r\n                    while(after && after.id < executionId){\r\n                        if(after.receiveArguments){\r\n                            var newResults = after.advice.apply(this, args);\r\n                            // change the return value only if a new value was returned\r\n                            results = newResults === undefined ? results : newResults;\r\n                        }else{\r\n                            results = after.advice.call(this, results, args);\r\n                        }\r\n                        after = after.next;\r\n                    }\r\n                    return results;\r\n                };\r\n                if(existing){\r\n                    dispatcher.around = {advice: function(target, args){\r\n                        return existing.apply(target, args);\r\n                    }};\r\n                }\r\n                dispatcher.target = target;\r\n            }\r\n            var results = advise((dispatcher || existing), type, advice, receiveArguments);\r\n            advice = null;\r\n            return results;\r\n        };\r\n    }\r\n\r\n    return {\r\n        after: aspect(\"after\"),\r\n \r\n        around: aspect(\"around\"),\r\n        \r\n        before: aspect(\"before\")\r\n    };\r\n});"]}