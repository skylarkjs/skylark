{"version":3,"sources":["popup.js"],"names":["define","skylark","langx","noder","styles","geom","eventer","popup","Array","prototype","some","mixin"],"mappings":";;;;;;;AAAAA,QACI,YACA,UACA,UACA,WACA,SACA,aACD,SAASC,EAAQC,EAAMC,EAAMC,EAAOC,EAAKC,GAgMxC,QAASC,KACL,MAAOA,GA/LAC,MAAMC,UAAUC,IAuM3B,OALAR,GAAMS,MAAMJ,MAKLN,EAAQM,MAAQA","file":"../popup.js","sourcesContent":["define([\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./noder\",\r\n    \"./styles\",\r\n    \"./geom\",\r\n    \"./eventer\"\r\n], function(skylark,langx,noder,styles,geom,eventer) {\r\n\r\n    var some = Array.prototype.some,\r\n        stack = [],\r\n        beginZIndex = 10000,\r\n        idGen = 1;\r\n\r\n\r\n\r\n    function close(elm,params){\r\n        // summary:\r\n        //      Close specified popup and any popups that it parented.\r\n        //      If no popup is specified, closes all popups.\r\n\r\n        var idx = -1;\r\n        for (var i=stack.length-1;i>-1;i--) {\r\n            if (stack[i].elm == elm) {\r\n                idx = i;\r\n                break;\r\n            }\r\n        }\r\n        while (stack.length){\r\n            var top = stack.pop(),\r\n                widget = top.widget,\r\n                onClose = top.onClose;\r\n\r\n            if(widget.onClose){\r\n                // TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here).\r\n                // Actually, StackContainer also calls onClose(), but to mean that the pane is being deleted\r\n                // (i.e. that the TabContainer's tab's [x] icon was clicked)\r\n                widget.onClose();\r\n            }\r\n\r\n            var h;\r\n            while(h = top.handlers.pop()){\r\n                h.remove();\r\n            }\r\n\r\n            // Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.\r\n            if(widget && widget.domNode){\r\n                this.hide(widget);\r\n            }\r\n\r\n            if(onClose){\r\n                onClose();\r\n            }\r\n            if (top == elm) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(stack.length == 0 && this._aroundMoveListener){\r\n            clearTimeout(this._aroundMoveListener);\r\n            this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;\r\n        }\r\n    }\r\n\r\n    function open(elm,args) {\r\n\r\n        while(stack.length && (!args.parent || !noder.contains(args.parent.domNode, stack[stack.length - 1].widget.domNode))){\r\n            this.close(stack[stack.length - 1].widget);\r\n        }\r\n\r\n        var stack = this._stack,\r\n            widget = args.popup,\r\n            node = widget.domNode,\r\n            orient = args.orient || [\"below\", \"below-alt\", \"above\", \"above-alt\"],\r\n            ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(widget.ownerDocument),\r\n            around = args.around,\r\n            id = (args.around && args.around.id) ? (args.around.id + \"_dropdown\") : (\"popup_\" + this._idGen++);\r\n\r\n        // If we are opening a new popup that isn't a child of a currently opened popup, then\r\n        // close currently opened popup(s).   This should happen automatically when the old popups\r\n        // gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].\r\n        while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length - 1].widget.domNode))){\r\n            this.close(stack[stack.length - 1].widget);\r\n        }\r\n\r\n        // Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep\r\n        // off screen) so we can do sizing calculations.\r\n        var wrapper = this.moveOffScreen(widget);\r\n\r\n        if(widget.startup && !widget._started){\r\n            widget.startup(); // this has to be done after being added to the DOM\r\n        }\r\n\r\n        // Limit height to space available in viewport either above or below aroundNode (whichever side has more\r\n        // room), adding scrollbar if necessary. Can't add scrollbar to widget because it may be a <table> (ex:\r\n        // dijit/Menu), so add to wrapper, and then move popup's border to wrapper so scroll bar inside border.\r\n        var maxHeight, popupSize = domGeometry.position(node);\r\n        if(\"maxHeight\" in args && args.maxHeight != -1){\r\n            maxHeight = args.maxHeight || Infinity; // map 0 --> infinity for back-compat of _HasDropDown.maxHeight\r\n        }else{\r\n            var viewport = Viewport.getEffectiveBox(this.ownerDocument),\r\n                aroundPos = around ? domGeometry.position(around, false) : {y: args.y - (args.padding||0), h: (args.padding||0) * 2};\r\n            maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));\r\n        }\r\n        if(popupSize.h > maxHeight){\r\n            // Get style of popup's border.  Unfortunately domStyle.get(node, \"border\") doesn't work on FF or IE,\r\n            // and domStyle.get(node, \"borderColor\") etc. doesn't work on FF, so need to use fully qualified names.\r\n            var cs = domStyle.getComputedStyle(node),\r\n                borderStyle = cs.borderLeftWidth + \" \" + cs.borderLeftStyle + \" \" + cs.borderLeftColor;\r\n            domStyle.set(wrapper, {\r\n                overflowY: \"scroll\",\r\n                height: maxHeight + \"px\",\r\n                border: borderStyle // so scrollbar is inside border\r\n            });\r\n            node._originalStyle = node.style.cssText;\r\n            node.style.border = \"none\";\r\n        }\r\n\r\n        domAttr.set(wrapper, {\r\n            id: id,\r\n            style: {\r\n                zIndex: this._beginZIndex + stack.length\r\n            },\r\n            \"class\": \"dijitPopup \" + (widget.baseClass || widget[\"class\"] || \"\").split(\" \")[0] + \"Popup\",\r\n            dijitPopupParent: args.parent ? args.parent.id : \"\"\r\n        });\r\n\r\n        if(stack.length == 0 && around){\r\n            // First element on stack. Save position of aroundNode and setup listener for changes to that position.\r\n            this._firstAroundNode = around;\r\n            this._firstAroundPosition = domGeometry.position(around, true);\r\n            this._aroundMoveListener = setTimeout(lang.hitch(this, \"_repositionAll\"), 50);\r\n        }\r\n\r\n        if(has(\"config-bgIframe\") && !widget.bgIframe){\r\n            // setting widget.bgIframe triggers cleanup in _WidgetBase.destroyRendering()\r\n            widget.bgIframe = new BackgroundIframe(wrapper);\r\n        }\r\n\r\n        // position the wrapper node and make it visible\r\n        var layoutFunc = widget.orient ? lang.hitch(widget, \"orient\") : null,\r\n            best = around ?\r\n                place.around(wrapper, around, orient, ltr, layoutFunc) :\r\n                place.at(wrapper, args, orient == 'R' ? ['TR', 'BR', 'TL', 'BL'] : ['TL', 'BL', 'TR', 'BR'], args.padding,\r\n                    layoutFunc);\r\n\r\n        wrapper.style.visibility = \"visible\";\r\n        node.style.visibility = \"visible\";  // counteract effects from _HasDropDown\r\n\r\n        var handlers = [];\r\n\r\n        // provide default escape and tab key handling\r\n        // (this will work for any widget, not just menu)\r\n        handlers.push(on(wrapper, \"keydown\", lang.hitch(this, function(evt){\r\n            if(evt.keyCode == keys.ESCAPE && args.onCancel){\r\n                evt.stopPropagation();\r\n                evt.preventDefault();\r\n                args.onCancel();\r\n            }else if(evt.keyCode == keys.TAB){\r\n                evt.stopPropagation();\r\n                evt.preventDefault();\r\n                var topPopup = this.getTopPopup();\r\n                if(topPopup && topPopup.onCancel){\r\n                    topPopup.onCancel();\r\n                }\r\n            }\r\n        })));\r\n\r\n        // watch for cancel/execute events on the popup and notify the caller\r\n        // (for a menu, \"execute\" means clicking an item)\r\n        if(widget.onCancel && args.onCancel){\r\n            handlers.push(widget.on(\"cancel\", args.onCancel));\r\n        }\r\n\r\n        handlers.push(widget.on(widget.onExecute ? \"execute\" : \"change\", lang.hitch(this, function(){\r\n            var topPopup = this.getTopPopup();\r\n            if(topPopup && topPopup.onExecute){\r\n                topPopup.onExecute();\r\n            }\r\n        })));\r\n\r\n        stack.push({\r\n            widget: widget,\r\n            wrapper: wrapper,\r\n            parent: args.parent,\r\n            onExecute: args.onExecute,\r\n            onCancel: args.onCancel,\r\n            onClose: args.onClose,\r\n            handlers: handlers\r\n        });\r\n\r\n        if(widget.onOpen){\r\n            // TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)\r\n            widget.onOpen(best);\r\n        }\r\n\r\n        return best;\r\n    }\r\n\r\n    function popup() {\r\n        return popup;\r\n    }\r\n\r\n    langx.mixin(popup, {\r\n\r\n    });\r\n\r\n\r\n    return skylark.popup = popup;\r\n});\r\n"]}