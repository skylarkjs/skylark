{"version":3,"sources":["mover.js"],"names":["define","skylark","langx","noder","datax","geom","eventer","styler","_place","node","choices","layoutNode","aroundNodeCoords","doc","ownerDoc","win","ownerWindow","view","size","left","top","parentNode","String","tagName","toLowerCase","body","appendChild","best","some","apply","choice","corner","pos","overflow","spaceAvailable","w","L","width","x","R","M","charAt","h","T","height","y","B","res","aroundCorner","bb","startXpos","Math","max","min","startYpos","startX","startY","endX","endY","boundingPosition","at","corners","padding","map","c","reverse","around","anchor","positions","leftToRight","push","aroundNodePos","domGeometry","position","test","anchorBorder","getBorderExtents","anchorChildBorder","firstChild","t","l","b","r","nodeBorder","nodeChildBorder","sawPosAbsolute","domStyle","getComputedStyle","parent","nodeType","nodeName","parentPos","pcs","bottomYCoord","rightXCoord","kernel","deprecated","array","forEach","ltr","movable","elm","params","updateWithTouchData","e","keys","i","changedTouches","split","length","overlayDiv","downButton","start","stop","originalPos","handleEl","handle","auto","constraints","document","startedCallback","started","movingCallback","moving","stoppedCallback","stopped","cursor","docSize","getDocumentSize","preventDefault","button","screenX","screenY","relativePosition","css","createElement","zIndex","opacity","append","on","move","deltaX","deltaY","minX","maxX","minY","maxY","off","remove","mover","attr","removeAttr","pagePosition","addClass","Array","prototype","mixin"],"mappings":"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","file":"../mover.js","sourcesContent":["define([\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./noder\",\r\n    \"./datax\",\r\n    \"./geom\",\r\n    \"./eventer\",\r\n    \"./styler\"\r\n],function(skylark, langx,noder,datax,geom,eventer,styler){\r\n    var on = eventer.on,\r\n        off = eventer.off,\r\n        attr = datax.attr,\r\n        removeAttr = datax.removeAttr,\r\n        offset = geom.pagePosition,\r\n        addClass = styler.addClass,\r\n        height = geom.height,\r\n        some = Array.prototype.some,\r\n        map = Array.prototype.map;\r\n\r\n    function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){\r\n        // summary:\r\n        //      Given a list of spots to put node, put it at the first spot where it fits,\r\n        //      of if it doesn't fit anywhere then the place with the least overflow\r\n        // choices: Array\r\n        //      Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }\r\n        //      Above example says to put the top-left corner of the node at (10,20)\r\n        // layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)\r\n        //      for things like tooltip, they are displayed differently (and have different dimensions)\r\n        //      based on their orientation relative to the parent.   This adjusts the popup based on orientation.\r\n        //      It also passes in the available size for the popup, which is useful for tooltips to\r\n        //      tell them that their width is limited to a certain amount.   layoutNode() may return a value expressing\r\n        //      how much the popup had to be modified to fit into the available space.   This is used to determine\r\n        //      what the best placement is.\r\n        // aroundNodeCoords: Object\r\n        //      Size of aroundNode, ex: {w: 200, h: 50}\r\n\r\n        // get {x: 10, y: 10, w: 100, h:100} type obj representing position of\r\n        // viewport over document\r\n\r\n        var doc = noder.ownerDoc(node),\r\n            win = noder.ownerWindow(doc),\r\n            view = geom.size(win);\r\n\r\n        view.left = 0;\r\n        view.top = 0;\r\n\r\n        if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != \"body\"){\r\n            doc.body.appendChild(node);\r\n        }\r\n\r\n        var best = null;\r\n\r\n        some.apply(choices, function(choice){\r\n            var corner = choice.corner;\r\n            var pos = choice.pos;\r\n            var overflow = 0;\r\n\r\n            // calculate amount of space available given specified position of node\r\n            var spaceAvailable = {\r\n                w: {\r\n                    'L': view.left + view.width - pos.x,\r\n                    'R': pos.x - view.left,\r\n                    'M': view.width\r\n                }[corner.charAt(1)],\r\n\r\n                h: {\r\n                    'T': view.top + view.height - pos.y,\r\n                    'B': pos.y - view.top,\r\n                    'M': view.height\r\n                }[corner.charAt(0)]\r\n            };\r\n\r\n            if(layoutNode){\r\n                var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);\r\n                overflow = typeof res == \"undefined\" ? 0 : res;\r\n            }\r\n\r\n            var bb = geom.size(node);\r\n\r\n            // coordinates and size of node with specified corner placed at pos,\r\n            // and clipped by viewport\r\n            var\r\n                startXpos = {\r\n                    'L': pos.x,\r\n                    'R': pos.x - bb.width,\r\n                    'M': Math.max(view.left, Math.min(view.left + view.width, pos.x + (bb.width >> 1)) - bb.width) // M orientation is more flexible\r\n                }[corner.charAt(1)],\r\n\r\n                startYpos = {\r\n                    'T': pos.y,\r\n                    'B': pos.y - bb.height,\r\n                    'M': Math.max(view.top, Math.min(view.top + view.height, pos.y + (bb.height >> 1)) - bb.height)\r\n                }[corner.charAt(0)],\r\n\r\n                startX = Math.max(view.left, startXpos),\r\n                startY = Math.max(view.top, startYpos),\r\n                endX = Math.min(view.left + view.width, startXpos + bb.width),\r\n                endY = Math.min(view.top + view.height, startYpos + bb.height),\r\n                width = endX - startX,\r\n                height = endY - startY;\r\n\r\n            overflow += (bb.width - width) + (bb.height - height);\r\n\r\n            if(best == null || overflow < best.overflow){\r\n                best = {\r\n                    corner: corner,\r\n                    aroundCorner: choice.aroundCorner,\r\n                    left: startX,\r\n                    top: startY,\r\n                    width: width,\r\n                    height: height,\r\n                    overflow: overflow,\r\n                    spaceAvailable: spaceAvailable\r\n                };\r\n            }\r\n\r\n            return !overflow;\r\n        });\r\n\r\n        // In case the best position is not the last one we checked, need to call\r\n        // layoutNode() again.\r\n        if(best.overflow && layoutNode){\r\n            layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);\r\n        }\r\n\r\n\r\n        geom.boundingPosition(node,best);\r\n\r\n        return best;\r\n    }\r\n\r\n    function at(node, pos, corners, padding, layoutNode){\r\n        var choices = map.apply(corners, function(corner){\r\n            var c = {\r\n                corner: corner,\r\n                aroundCorner: reverse[corner],  // so TooltipDialog.orient() gets aroundCorner argument set\r\n                pos: {x: pos.x,y: pos.y}\r\n            };\r\n            if(padding){\r\n                c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;\r\n                c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;\r\n            }\r\n            return c;\r\n        });\r\n\r\n        return _place(node, choices, layoutNode);\r\n    }\r\n\r\n    function around(\r\n        /*DomNode*/     node,\r\n        /*DomNode|__Rectangle*/ anchor,\r\n        /*String[]*/    positions,\r\n        /*Boolean*/     leftToRight,\r\n        /*Function?*/   layoutNode){\r\n\r\n        // summary:\r\n        //      Position node adjacent or kitty-corner to anchor\r\n        //      such that it's fully visible in viewport.\r\n        // description:\r\n        //      Place node such that corner of node touches a corner of\r\n        //      aroundNode, and that node is fully visible.\r\n        // anchor:\r\n        //      Either a DOMNode or a rectangle (object with x, y, width, height).\r\n        // positions:\r\n        //      Ordered list of positions to try matching up.\r\n        //\r\n        //      - before: places drop down to the left of the anchor node/widget, or to the right in the case\r\n        //          of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down\r\n        //          with the top of the anchor, or the bottom of the drop down with bottom of the anchor.\r\n        //      - after: places drop down to the right of the anchor node/widget, or to the left in the case\r\n        //          of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down\r\n        //          with the top of the anchor, or the bottom of the drop down with bottom of the anchor.\r\n        //      - before-centered: centers drop down to the left of the anchor node/widget, or to the right\r\n        //          in the case of RTL scripts like Hebrew and Arabic\r\n        //      - after-centered: centers drop down to the right of the anchor node/widget, or to the left\r\n        //          in the case of RTL scripts like Hebrew and Arabic\r\n        //      - above-centered: drop down is centered above anchor node\r\n        //      - above: drop down goes above anchor node, left sides aligned\r\n        //      - above-alt: drop down goes above anchor node, right sides aligned\r\n        //      - below-centered: drop down is centered above anchor node\r\n        //      - below: drop down goes below anchor node\r\n        //      - below-alt: drop down goes below anchor node, right sides aligned\r\n        // layoutNode: Function(node, aroundNodeCorner, nodeCorner)\r\n        //      For things like tooltip, they are displayed differently (and have different dimensions)\r\n        //      based on their orientation relative to the parent.   This adjusts the popup based on orientation.\r\n        // leftToRight:\r\n        //      True if widget is LTR, false if widget is RTL.   Affects the behavior of \"above\" and \"below\"\r\n        //      positions slightly.\r\n        // example:\r\n        //  |   placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});\r\n        //      This will try to position node such that node's top-left corner is at the same position\r\n        //      as the bottom left corner of the aroundNode (ie, put node below\r\n        //      aroundNode, with left edges aligned).   If that fails it will try to put\r\n        //      the bottom-right corner of node where the top right corner of aroundNode is\r\n        //      (ie, put node above aroundNode, with right edges aligned)\r\n        //\r\n\r\n        // If around is a DOMNode (or DOMNode id), convert to coordinates.\r\n        var aroundNodePos;\r\n        if(typeof anchor == \"string\" || \"offsetWidth\" in anchor || \"ownerSVGElement\" in anchor){\r\n            aroundNodePos = domGeometry.position(anchor, true);\r\n\r\n            // For above and below dropdowns, subtract width of border so that popup and aroundNode borders\r\n            // overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border\r\n            // width of either anchor or popup because in both cases the border may be on an inner node.\r\n            if(/^(above|below)/.test(positions[0])){\r\n                var anchorBorder = domGeometry.getBorderExtents(anchor),\r\n                    anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},\r\n                    nodeBorder =  domGeometry.getBorderExtents(node),\r\n                    nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};\r\n                aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);\r\n                aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +\r\n                    Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);\r\n            }\r\n        }else{\r\n            aroundNodePos = anchor;\r\n        }\r\n\r\n        // Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)\r\n        if(anchor.parentNode){\r\n            // ignore nodes between position:relative and position:absolute\r\n            var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == \"absolute\";\r\n            var parent = anchor.parentNode;\r\n            while(parent && parent.nodeType == 1 && parent.nodeName != \"BODY\"){  //ignoring the body will help performance\r\n                var parentPos = domGeometry.position(parent, true),\r\n                    pcs = domStyle.getComputedStyle(parent);\r\n                if(/relative|absolute/.test(pcs.position)){\r\n                    sawPosAbsolute = false;\r\n                }\r\n                if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){\r\n                    var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);\r\n                    var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);\r\n                    aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);\r\n                    aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);\r\n                    aroundNodePos.h = bottomYCoord - aroundNodePos.y;\r\n                    aroundNodePos.w = rightXCoord - aroundNodePos.x;\r\n                }\r\n                if(pcs.position == \"absolute\"){\r\n                    sawPosAbsolute = true;\r\n                }\r\n                parent = parent.parentNode;\r\n            }\r\n        }           \r\n\r\n        var x = aroundNodePos.x,\r\n            y = aroundNodePos.y,\r\n            width = \"w\" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),\r\n            height = \"h\" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated(\"place.around: dijit/place.__Rectangle: { x:\"+x+\", y:\"+y+\", height:\"+aroundNodePos.height+\", width:\"+width+\" } has been deprecated.  Please use { x:\"+x+\", y:\"+y+\", h:\"+aroundNodePos.height+\", w:\"+width+\" }\", \"\", \"2.0\"), aroundNodePos.h = aroundNodePos.height);\r\n\r\n        // Convert positions arguments into choices argument for _place()\r\n        var choices = [];\r\n        function push(aroundCorner, corner){\r\n            choices.push({\r\n                aroundCorner: aroundCorner,\r\n                corner: corner,\r\n                pos: {\r\n                    x: {\r\n                        'L': x,\r\n                        'R': x + width,\r\n                        'M': x + (width >> 1)\r\n                    }[aroundCorner.charAt(1)],\r\n                    y: {\r\n                        'T': y,\r\n                        'B': y + height,\r\n                        'M': y + (height >> 1)\r\n                    }[aroundCorner.charAt(0)]\r\n                }\r\n            })\r\n        }\r\n        array.forEach(positions, function(pos){\r\n            var ltr =  leftToRight;\r\n            switch(pos){\r\n                case \"above-centered\":\r\n                    push(\"TM\", \"BM\");\r\n                    break;\r\n                case \"below-centered\":\r\n                    push(\"BM\", \"TM\");\r\n                    break;\r\n                case \"after-centered\":\r\n                    ltr = !ltr;\r\n                    // fall through\r\n                case \"before-centered\":\r\n                    push(ltr ? \"ML\" : \"MR\", ltr ? \"MR\" : \"ML\");\r\n                    break;\r\n                case \"after\":\r\n                    ltr = !ltr;\r\n                    // fall through\r\n                case \"before\":\r\n                    push(ltr ? \"TL\" : \"TR\", ltr ? \"TR\" : \"TL\");\r\n                    push(ltr ? \"BL\" : \"BR\", ltr ? \"BR\" : \"BL\");\r\n                    break;\r\n                case \"below-alt\":\r\n                    ltr = !ltr;\r\n                    // fall through\r\n                case \"below\":\r\n                    // first try to align left borders, next try to align right borders (or reverse for RTL mode)\r\n                    push(ltr ? \"BL\" : \"BR\", ltr ? \"TL\" : \"TR\");\r\n                    push(ltr ? \"BR\" : \"BL\", ltr ? \"TR\" : \"TL\");\r\n                    break;\r\n                case \"above-alt\":\r\n                    ltr = !ltr;\r\n                    // fall through\r\n                case \"above\":\r\n                    // first try to align left borders, next try to align right borders (or reverse for RTL mode)\r\n                    push(ltr ? \"TL\" : \"TR\", ltr ? \"BL\" : \"BR\");\r\n                    push(ltr ? \"TR\" : \"TL\", ltr ? \"BR\" : \"BL\");\r\n                    break;\r\n                default:\r\n                    // To assist dijit/_base/place, accept arguments of type {aroundCorner: \"BL\", corner: \"TL\"}.\r\n                    // Not meant to be used directly.  Remove for 2.0.\r\n                    push(pos.aroundCorner, pos.corner);\r\n            }\r\n        });\r\n\r\n        var position = _place(node, choices, layoutNode, {w: width, h: height});\r\n        position.aroundNodePos = aroundNodePos;\r\n\r\n        return position;\r\n    }\r\n\r\n    function movable(elm, params) {\r\n        function updateWithTouchData(e) {\r\n            var keys, i;\r\n\r\n            if (e.changedTouches) {\r\n                keys = \"screenX screenY pageX pageY clientX clientY\".split(' ');\r\n                for (i = 0; i < keys.length; i++) {\r\n                    e[keys[i]] = e.changedTouches[0][keys[i]];\r\n                }\r\n            }\r\n        }\r\n\r\n        params = params || {};\r\n        var handleEl = params.handle || elm,\r\n            auto = params.auto === false ? false : true,\r\n            constraints = params.constraints,\r\n            overlayDiv,\r\n            doc = params.document || document,\r\n            downButton,\r\n            start,\r\n            stop,\r\n            drag,\r\n            startX,\r\n            startY,\r\n            originalPos,\r\n            size,\r\n            startedCallback = params.started,\r\n            movingCallback = params.moving,\r\n            stoppedCallback = params.stopped,\r\n\r\n            start = function(e) {\r\n                var docSize = geom.getDocumentSize(doc),\r\n                    cursor;\r\n\r\n                updateWithTouchData(e);\r\n\r\n                e.preventDefault();\r\n                downButton = e.button;\r\n                //handleEl = getHandleEl();\r\n                startX = e.screenX;\r\n                startY = e.screenY;\r\n\r\n                originalPos = geom.relativePosition(elm);\r\n                size = geom.size(elm);\r\n\r\n                // Grab cursor from handle so we can place it on overlay\r\n                cursor = styler.css(handleEl, \"curosr\");\r\n\r\n                overlayDiv = noder.createElement(\"div\");\r\n                styler.css(overlayDiv, {\r\n                    position: \"absolute\",\r\n                    top: 0,\r\n                    left: 0,\r\n                    width: docSize.width,\r\n                    height: docSize.height,\r\n                    zIndex: 0x7FFFFFFF,\r\n                    opacity: 0.0001,\r\n                    cursor: cursor\r\n                });\r\n                noder.append(doc.body, overlayDiv);\r\n\r\n                eventer.on(doc, \"mousemove touchmove\", move).on(doc, \"mouseup touchend\", stop);\r\n\r\n                if (startedCallback) {\r\n                    startedCallback(e);\r\n                }\r\n            },\r\n\r\n            move = function(e) {\r\n                updateWithTouchData(e);\r\n\r\n                if (e.button !== 0) {\r\n                    return stop(e);\r\n                }\r\n\r\n                e.deltaX = e.screenX - startX;\r\n                e.deltaY = e.screenY - startY;\r\n\r\n                if (auto) {\r\n                    var l = originalPos.left + e.deltaX,\r\n                        t = originalPos.top + e.deltaY;\r\n                    if (constraints) {\r\n\r\n                        if (l < constraints.minX) {\r\n                            l = constraints.minX;\r\n                        }\r\n\r\n                        if (l > constraints.maxX) {\r\n                            l = constraints.maxX;\r\n                        }\r\n\r\n                        if (t < constraints.minY) {\r\n                            t = constraints.minY;\r\n                        }\r\n\r\n                        if (t > constraints.maxY) {\r\n                            t = constraints.maxY;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                geom.relativePosition(elm, {\r\n                    left: l,\r\n                    top: t\r\n                })\r\n\r\n                e.preventDefault();\r\n                if (movingCallback) {\r\n                    movingCallback(e);\r\n                }\r\n            },\r\n\r\n            stop = function(e) {\r\n                updateWithTouchData(e);\r\n\r\n                eventer.off(doc, \"mousemove touchmove\", move).off(doc, \"mouseup touchend\", stop);\r\n\r\n                noder.remove(overlayDiv);\r\n\r\n                if (stoppedCallback) {\r\n                    stoppedCallback(e);\r\n                }\r\n            };\r\n\r\n        eventer.on(handleEl, \"mousedown touchstart\", start);\r\n\r\n        return {\r\n            // destroys the dragger.\r\n            remove: function() {\r\n                eventer.off(handleEl);\r\n            }\r\n        }\r\n    }\r\n\r\n    function mover(){\r\n      return mover;\r\n    }\r\n\r\n    langx.mixin(mover, {\r\n        around : around,\r\n\r\n        at: at, \r\n\r\n        movable: movable\r\n\r\n    });\r\n\r\n    return skylark.mover = mover;\r\n});\r\n"]}