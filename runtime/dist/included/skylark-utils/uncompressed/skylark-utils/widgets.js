define([
    "./skylark",
    "./langx",
    "./noder",
    "./datax",
    "./styler",
    "./geom",
    "./eventer",
    "./query",
    "./velm"
], function(skylark,langx,noder, datax, styler, geom, eventer,query,velm) {
	// Cached regex to split keys for `delegate`.
	var delegateEventSplitter = /^(\S+)\s*(.*)$/,
		slice = Array.prototype.slice;


	function bridge( name, object ) {
		var fullName = object.prototype.widgetFullName || name,
			fn = {};

		function _delegate (isQuery) {

		}

		fn[name] = function( options ) {
			var isMethodCall = typeof options === "string";
			var args = slice.call( arguments, 1 );
			var returnValue = this;

			if ( isMethodCall ) {

				// If this is an empty collection, we need to have the instance method
				// return undefined instead of the jQuery instance
				if ( !this.length && options === "instance" ) {
					returnValue = undefined;
				} else {
					this.each( function() {
						var methodValue;
						var instance = datax.data( this, fullName );

						if ( options === "instance" ) {
							returnValue = instance;
							return false;
						}

						if ( !instance ) {
							return $.error( "cannot call methods on " + name +
								" prior to initialization; " +
								"attempted to call method '" + options + "'" );
						}

						if ( !langx.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
							return $.error( "no such method '" + options + "' for " + name +
								" widget instance" );
						}

						methodValue = instance[ options ].apply( instance, args );

						if ( methodValue !== instance && methodValue !== undefined ) {
							returnValue = methodValue && methodValue.jquery ?
								returnValue.pushStack( methodValue.get() ) :
								methodValue;
							return false;
						}
					} );
				}
			} else {

				// Allow multiple hashes to be passed on init
				if ( args.length ) {
					options = $.widget.extend.apply( null, [ options ].concat( args ) );
				}

				this.each( function() {
					var instance = datax.data( this, fullName );
					if ( instance ) {
						instance.option( options || {} );
						if ( instance._init ) {
							instance._init();
						}
					} else {
						datax.data( this, fullName, new object( options, this ) );
					}
				} );
			}

			return returnValue;
		};
	};

	function widgets() {
	    return widgets;
	}

	var Widget = langx.Evented.inherit({
	    init :function(el,options) {
	    	//for supporting init(options,el)
	        if (langx.isHtmlNode(options)) {
	        	var _t = el,
	        		options = el;
	            el = options;
	        }
	        if (langx.isHtmlNode(el)) { 
	        	this.el = el;
	    	} else {
	    		this.el = null;
	    	}
	        if (options) {
	            langx.mixin(this,options);
	        }
	        if (!this.cid) {
	            this.cid = langx.uniqueId('w');
	        }
	        this._ensureElement();
	    },

	    // The default `tagName` of a View's element is `"div"`.
	    tagName: 'div',

	    // query delegate for element lookup, scoped to DOM elements within the
	    // current view. This should be preferred to global lookups where possible.
	    $: function(selector) {
	      return this.$el.find(selector);
	    },

	    // **render** is the core function that your view should override, in order
	    // to populate its element (`this.el`), with the appropriate HTML. The
	    // convention is for **render** to always return `this`.
	    render: function() {
	      return this;
	    },

	    // Remove this view by taking the element out of the DOM, and removing any
	    // applicable Backbone.Events listeners.
	    remove: function() {
	      this._removeElement();
	      this.unlistenTo();
	      return this;
	    },

	    // Remove this view's element from the document and all event listeners
	    // attached to it. Exposed for subclasses using an alternative DOM
	    // manipulation API.
	    _removeElement: function() {
	      this.$el.remove();
	    },

	    // Change the view's element (`this.el` property) and re-delegate the
	    // view's events on the new element.
	    setElement: function(element) {
	      this.undelegateEvents();
	      this._setElement(element);
	      this.delegateEvents();
	      return this;
	    },

	    // Creates the `this.el` and `this.$el` references for this view using the
	    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
	    // context or an element. Subclasses can override this to utilize an
	    // alternative DOM manipulation API and are only required to set the
	    // `this.el` property.
	    _setElement: function(el) {
	      this.$el = widgets.$(el);
	      this.el = this.$el[0];
	    },

	    // Set callbacks, where `this.events` is a hash of
	    //
	    // *{"event selector": "callback"}*
	    //
	    //     {
	    //       'mousedown .title':  'edit',
	    //       'click .button':     'save',
	    //       'click .open':       function(e) { ... }
	    //     }
	    //
	    // pairs. Callbacks will be bound to the view, with `this` set properly.
	    // Uses event delegation for efficiency.
	    // Omitting the selector binds the event to `this.el`.
	    delegateEvents: function(events) {
	      events || (events = langx.result(this, 'events'));
	      if (!events) return this;
	      this.undelegateEvents();
	      for (var key in events) {
	        var method = events[key];
	        if (!langx.isFunction(method)) method = this[method];
	        if (!method) continue;
	        var match = key.match(delegateEventSplitter);
	        this.delegate(match[1], match[2], langx.proxy(method, this));
	      }
	      return this;
	    },

	    // Add a single event listener to the view's element (or a child element
	    // using `selector`). This only works for delegate-able events: not `focus`,
	    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
	    delegate: function(eventName, selector, listener) {
	      this.$el.on(eventName + '.delegateEvents' + this.uid, selector, listener);
	      return this;
	    },

	    // Clears all callbacks previously bound to the view by `delegateEvents`.
	    // You usually don't need to use this, but may wish to if you have multiple
	    // Backbone views attached to the same DOM element.
	    undelegateEvents: function() {
	      if (this.$el) this.$el.off('.delegateEvents' + this.uid);
	      return this;
	    },

	    // A finer-grained `undelegateEvents` for removing a single delegated event.
	    // `selector` and `listener` are both optional.
	    undelegate: function(eventName, selector, listener) {
	      this.$el.off(eventName + '.delegateEvents' + this.uid, selector, listener);
	      return this;
	    },

	    // Produces a DOM element to be assigned to your view. Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _createElement: function(tagName,attrs) {
	      return noder.createElement(tagName,attrs);
	    },

	    // Ensure that the View has a DOM element to render into.
	    // If `this.el` is a string, pass it through `$()`, take the first
	    // matching element, and re-assign it to `el`. Otherwise, create
	    // an element from the `id`, `className` and `tagName` properties.
	    _ensureElement: function() {
	      if (!this.el) {
	        var attrs = langx.mixin({}, langx.result(this, 'attributes'));
	        if (this.id) attrs.id = langx.result(this, 'id');
	        if (this.className) attrs['class'] = langx.result(this, 'className');
	        this.setElement(this._createElement(langx.result(this, 'tagName'),attrs));
	        this._setAttributes(attrs);
	      } else {
	        this.setElement(langx.result(this, 'el'));
	      }
	    },

	    // Set attributes from a hash on this view's element.  Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _setAttributes: function(attributes) {
	      this.$el.attr(attributes);
	    },

	    // Translation function, gets the message key to be translated
	    // and an object with context specific data as arguments:
	    i18n: function (message, context) {
	        message = (this.messages && this.messages[message]) || message.toString();
	        if (context) {
	            langx.each(context, function (key, value) {
	                message = message.replace('{' + key + '}', value);
	            });
	        }
	        return message;
	    },

		});

	function defineWidgetClass(name,base,prototype) {

	};

	langx.mixin(widgets, {
		$ : query,

		define : defineWidgetClass,
		Widget : Widget
	});


	return skylark.widgets = widgets;
});
