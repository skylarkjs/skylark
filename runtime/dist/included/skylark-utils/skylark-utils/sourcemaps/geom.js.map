{"version":3,"sources":["geom.js"],"names":["define","skylark","langx","styler","offsetParent","elm","parent","document","body","rootNodeRE","test","nodeName","css","borderExtents","s","getComputedStyle","left","px","borderLeftWidth","top","borderTopWidth","right","borderRightWidth","bottom","borderBottomWidth","boundingPosition","coords","undefined","getBoundingClientRect","parentOffset","mex","marginExtents","pbex","relativePosition","this","boundingRect","size","clientHeight","value","clientSize","height","dimension","width","clientWidth","isBorderBox","props","bex","pex","paddingExtents","contentRect","cs","getDocumentSize","doc","documentElement","max","Math","scrollWidth","offsetWidth","scrollHeight","offsetHeight","marginLeft","marginTop","marginRight","marginBottom","marginRect","obj","relativeRect","me","paddingLeft","paddingTop","paddingRight","paddingBottom","pagePosition","window","pageXOffset","pageYOffset","pageRect","round","offset","scrollIntoView","align","getOffset","rootElm","x","y","nodeType","offsetLeft","offsetTop","parentWidth","parentHeight","parentElm","parentNode","pos","scrollLeft","scrollTop","hasScrollLeft","scrollTo","scrollY","hasScrollTop","scrollX","isWindow","innerWidth","innerHeight","isDocument","geom","toPixel","mixin"],"mappings":"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","file":"../geom.js","sourcesContent":["define([\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./styler\"\r\n], function(skylark, langx, styler) {\r\n    var rootNodeRE = /^(?:body|html)$/i,\r\n        px = langx.toPixel;\r\n\r\n    function offsetParent(elm) {\r\n        var parent = elm.offsetParent || document.body;\r\n        while (parent && !rootNodeRE.test(parent.nodeName) && styler.css(parent, \"position\") == \"static\") {\r\n            parent = parent.offsetParent;\r\n        }\r\n        return parent;\r\n    }\r\n\r\n\r\n    function borderExtents(elm) {\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.borderLeftWidth , elm),\r\n            top: px(s.borderTopWidth, elm),\r\n            right: px(s.borderRightWidth, elm),\r\n            bottom: px(s.borderBottomWidth, elm)\r\n        }\r\n    }\r\n\r\n    //viewport coordinate\r\n    function boundingPosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function boundingRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            return elm.getBoundingClientRect()\r\n        } else {\r\n            boundingPosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function clientHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).height;\r\n        } else {\r\n            return clientSize(elm, {\r\n                height: value\r\n            });\r\n        }\r\n    }\r\n\r\n    function clientSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            return {\r\n                width: elm.clientWidth,\r\n                height: elm.clientHeight\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width - pex.left - pex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height - pex.top - pex.bottom;\r\n                }\r\n            } else {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height + bex.top + bex.bottom;\r\n                }\r\n\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n        return {\r\n            width: elm.clientWidth,\r\n            height: elm.clientHeight\r\n        };\r\n    }\r\n\r\n    function clientWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).width;\r\n        } else {\r\n            clientSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function contentRect(elm) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n\r\n        //// On Opera, offsetLeft includes the parent's border\r\n        //if(has(\"opera\")){\r\n        //    pe.l += be.l;\r\n        //    pe.t += be.t;\r\n        //}\r\n        return {\r\n            left: pex.left,\r\n            top: pex.top,\r\n            width: cs.width - pex.left - pex.right,\r\n            height: cs.height - pex.top - pex.bottom\r\n        };\r\n    }\r\n\r\n    function getDocumentSize(doc) {\r\n        var documentElement = doc.documentElement,\r\n            body = doc.body,\r\n            max = Math.max,\r\n            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),\r\n            clientWidth = max(documentElement.clientWidth, body.clientWidth),\r\n            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),\r\n            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),\r\n            clientHeight = max(documentElement.clientHeight, body.clientHeight),\r\n            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\r\n\r\n        return {\r\n            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\r\n            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight\r\n        };\r\n    }\r\n\r\n    function height(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).height;\r\n        } else {\r\n            size(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function marginExtents(elm) {\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.marginLeft),\r\n            top: px(s.marginTop),\r\n            right: px(s.marginRight),\r\n            bottom: px(s.marginBottom),\r\n        }\r\n    }\r\n\r\n    function marginRect(elm) {\r\n        var obj = this.relativeRect(elm),\r\n            me = this.marginExtents(elm);\r\n\r\n        return {\r\n                left: obj.left,\r\n                top: obj.top,\r\n                width: obj.width + me.left + me.right,\r\n                height: obj.height + me.top + me.bottom\r\n            };\r\n    }\r\n\r\n\r\n    function paddingExtents(elm) {\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.paddingLeft),\r\n            top: px(s.paddingTop),\r\n            right: px(s.paddingRight),\r\n            bottom: px(s.paddingBottom),\r\n        }\r\n    }\r\n\r\n    //coordinate to the document\r\n    function pagePosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = pagePosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function pageRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset,\r\n                width: Math.round(obj.width),\r\n                height: Math.round(obj.height)\r\n            }\r\n        } else {\r\n            pagePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    // coordinate relative to it's parent\r\n    function relativePosition(elm, coords) {\r\n        if (coords == undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingPosition(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top,// - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left,// - mex.left\r\n            }\r\n        } else {\r\n            var props = {\r\n                top: coords.top,\r\n                left: coords.left\r\n            }\r\n\r\n            if (styler.css(elm, \"position\") == \"static\") {\r\n                props['position'] = \"relative\";\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function relativeRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingRect(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left,\r\n                width: offset.width,\r\n                height: offset.height\r\n            }\r\n        } else {\r\n            relativePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function scrollIntoView(elm, align) {\r\n        function getOffset(elm, rootElm) {\r\n            var x, y, parent = elm;\r\n\r\n            x = y = 0;\r\n            while (parent && parent != rootElm && parent.nodeType) {\r\n                x += parent.offsetLeft || 0;\r\n                y += parent.offsetTop || 0;\r\n                parent = parent.offsetParent;\r\n            }\r\n\r\n            return { x: x, y: y };\r\n        }\r\n\r\n        var parentElm = elm.parentNode;\r\n        var x, y, width, height, parentWidth, parentHeight;\r\n        var pos = getOffset(elm, parentElm);\r\n\r\n        x = pos.x;\r\n        y = pos.y;\r\n        width = elm.offsetWidth;\r\n        height = elm.offsetHeight;\r\n        parentWidth = parentElm.clientWidth;\r\n        parentHeight = parentElm.clientHeight;\r\n\r\n        if (align == \"end\") {\r\n            x -= parentWidth - width;\r\n            y -= parentHeight - height;\r\n        } else if (align == \"center\") {\r\n            x -= (parentWidth / 2) - (width / 2);\r\n            y -= (parentHeight / 2) - (height / 2);\r\n        }\r\n\r\n        parentElm.scrollLeft = x;\r\n        parentElm.scrollTop = y;\r\n\r\n        return this;\r\n    }\r\n\r\n    function scrollLeft(elm, value) {\r\n        var hasScrollLeft = \"scrollLeft\" in elm;\r\n        if (value === undefined) {\r\n            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset\r\n        } else {\r\n            if (hasScrollLeft) {\r\n                elm.scrollLeft = value;\r\n            } else {\r\n                elm.scrollTo(value, elm.scrollY);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function scrollTop(elm, value) {\r\n        var hasScrollTop = \"scrollTop\" in elm;\r\n\r\n        if (value === undefined) {\r\n            return hasScrollTop ? elm.scrollTop : elm.pageYOffset\r\n        } else {\r\n            if (hasScrollTop) {\r\n                elm.scrollTop = value;\r\n            } else {\r\n                elm.scrollTo(elm.scrollX, value);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function size(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            if (langx.isWindow(elm)) {\r\n                return {\r\n                    width: elm.innerWidth,\r\n                    height: elm.innerHeight\r\n                }\r\n\r\n            } else if (langx.isDocument(elm)) {\r\n                return getDocumentSize(document);\r\n            } else {\r\n                return {\r\n                    width: elm.offsetWidth,\r\n                    height: elm.offsetHeight\r\n                }\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm),\r\n                    bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function width(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).width;\r\n        } else {\r\n            size(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function geom() {\r\n        return geom;\r\n    }\r\n\r\n    langx.mixin(geom, {\r\n        borderExtents: borderExtents,\r\n        //viewport coordinate\r\n        boundingPosition: boundingPosition,\r\n\r\n        boundingRect: boundingRect,\r\n\r\n        clientHeight: clientHeight,\r\n\r\n        clientSize: clientSize,\r\n\r\n        clientWidth: clientWidth,\r\n\r\n        contentRect: contentRect,\r\n\r\n        getDocumentSize: getDocumentSize,\r\n\r\n        height: height,\r\n\r\n        marginExtents: marginExtents,\r\n\r\n        marginRect : marginRect,\r\n\r\n        offsetParent: offsetParent,\r\n\r\n        paddingExtents: paddingExtents,\r\n\r\n        //coordinate to the document\r\n        pagePosition: pagePosition,\r\n\r\n        pageRect: pageRect,\r\n\r\n        // coordinate relative to it's parent\r\n        relativePosition: relativePosition,\r\n\r\n        relativeRect: relativeRect,\r\n\r\n        scrollIntoView: scrollIntoView,\r\n\r\n        scrollLeft: scrollLeft,\r\n\r\n        scrollTop: scrollTop,\r\n\r\n        size: size,\r\n\r\n        width: width\r\n    });\r\n\r\n    return skylark.geom = geom;\r\n});\r\n"]}