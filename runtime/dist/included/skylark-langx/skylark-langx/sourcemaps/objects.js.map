{"version":3,"sources":["objects.js"],"names":["define","types","createAssigner","keysFunc","defaults","obj","length","arguments","Object","index","source","keys","l","i","key","allKeys","isObject","push","has","path","isArray","hasOwnProperty","call","isEqual","a","b","eq","isMatch","object","attrs","_mixin","target","deep","safe","undefined","isPlainObject","_parseMixinArgs","args","params","slice","shift","isBoolean","pop","sources","mixin","apply","this","forEach","removeItem","items","item","idx","indexOf","splice","result","fallback","isFunction","prop","safeMixin","values","_","Array","clone","src","checkCloneMethod","copy","deepEq","prototype","SymbolProto","Symbol","aStack","bStack","type","className","toString","valueOf","areArrays","aCtor","constructor","bCtor"],"mappings":"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","file":"../objects.js","sourcesContent":["define([\r\n\t\"./types\"\r\n],function(types){\r\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty,\r\n        slice = Array.prototype.slice,\r\n        isBoolean = types.isBoolean,\r\n        isFunction = types.isFunction,\r\n\t\tisObject = types.isObject,\r\n\t\tisPlainObject = types.isPlainObject,\r\n\t\tisArray = types.isArray;\r\n\r\n     // An internal function for creating assigner functions.\r\n    function createAssigner(keysFunc, defaults) {\r\n        return function(obj) {\r\n          var length = arguments.length;\r\n          if (defaults) obj = Object(obj);  \r\n          if (length < 2 || obj == null) return obj;\r\n          for (var index = 1; index < length; index++) {\r\n            var source = arguments[index],\r\n                keys = keysFunc(source),\r\n                l = keys.length;\r\n            for (var i = 0; i < l; i++) {\r\n              var key = keys[i];\r\n              if (!defaults || obj[key] === void 0) obj[key] = source[key];\r\n            }\r\n          }\r\n          return obj;\r\n       };\r\n    }\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    var eq, deepEq;\r\n    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\r\n\r\n    eq = function(a, b, aStack, bStack) {\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) return a !== 0 || 1 / a === 1 / b;\r\n        // `null` or `undefined` only equal to itself (strict comparison).\r\n        if (a == null || b == null) return false;\r\n        // `NaN`s are equivalent, but non-reflexive.\r\n        if (a !== a) return b !== b;\r\n        // Exhaust primitive checks\r\n        var type = typeof a;\r\n        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\r\n        return deepEq(a, b, aStack, bStack);\r\n    };\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    deepEq = function(a, b, aStack, bStack) {\r\n        // Unwrap any wrapped objects.\r\n        //if (a instanceof _) a = a._wrapped;\r\n        //if (b instanceof _) b = b._wrapped;\r\n        // Compare `[[Class]]` names.\r\n        var className = toString.call(a);\r\n        if (className !== toString.call(b)) return false;\r\n        switch (className) {\r\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\r\n            case '[object RegExp]':\r\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return '' + a === '' + b;\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive.\r\n                // Object(NaN) is equivalent to NaN.\r\n                if (+a !== +a) return +b !== +b;\r\n                // An `egal` comparison is performed for other numeric values.\r\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a === +b;\r\n            case '[object Symbol]':\r\n                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\r\n        }\r\n\r\n        var areArrays = className === '[object Array]';\r\n        if (!areArrays) {\r\n            if (typeof a != 'object' || typeof b != 'object') return false;\r\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\r\n                               isFunction(bCtor) && bCtor instanceof bCtor)\r\n                          && ('constructor' in a && 'constructor' in b)) {\r\n                return false;\r\n            }\r\n        }\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n\r\n        // Initializing stack of traversed objects.\r\n        // It's done here since we only need them for objects and arrays comparison.\r\n        aStack = aStack || [];\r\n        bStack = bStack || [];\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] === a) return bStack[length] === b;\r\n        }\r\n\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n\r\n        // Recursively compare objects and arrays.\r\n        if (areArrays) {\r\n            // Compare array lengths to determine if a deep comparison is necessary.\r\n            length = a.length;\r\n            if (length !== b.length) return false;\r\n            // Deep compare the contents, ignoring non-numeric properties.\r\n            while (length--) {\r\n                if (!eq(a[length], b[length], aStack, bStack)) return false;\r\n            }\r\n        } else {\r\n            // Deep compare objects.\r\n            var keys = Object.keys(a), key;\r\n            length = keys.length;\r\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n            if (Object.keys(b).length !== length) return false;\r\n            while (length--) {\r\n                // Deep compare each member\r\n                key = keys[length];\r\n                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n        return true;\r\n    };\r\n\r\n    // Retrieve all the property names of an object.\r\n    function allKeys(obj) {\r\n        if (!isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    // Retrieve the names of an object's own properties.\r\n    // Delegates to **ECMAScript 5**'s native `Object.keys`.\r\n    function keys(obj) {\r\n        if (isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) if (has(obj, key)) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    function has(obj, path) {\r\n        if (!isArray(path)) {\r\n            return obj != null && hasOwnProperty.call(obj, path);\r\n        }\r\n        var length = path.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var key = path[i];\r\n            if (obj == null || !hasOwnProperty.call(obj, key)) {\r\n                return false;\r\n            }\r\n            obj = obj[key];\r\n        }\r\n        return !!length;\r\n    }\r\n\r\n   // Perform a deep comparison to check if two objects are equal.\r\n    function isEqual(a, b) {\r\n        return eq(a, b);\r\n    }\r\n\r\n    // Returns whether an object has a given set of `key:value` pairs.\r\n    function isMatch(object, attrs) {\r\n        var keys = keys(attrs), length = keys.length;\r\n        if (object == null) return !length;\r\n        var obj = Object(object);\r\n        for (var i = 0; i < length; i++) {\r\n          var key = keys[i];\r\n          if (attrs[key] !== obj[key] || !(key in obj)) return false;\r\n        }\r\n        return true;\r\n    }    \r\n\r\n    function _mixin(target, source, deep, safe) {\r\n        for (var key in source) {\r\n            //if (!source.hasOwnProperty(key)) {\r\n            //    continue;\r\n            //}\r\n            if (safe && target[key] !== undefined) {\r\n                continue;\r\n            }\r\n            if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n                if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n                    target[key] = {};\r\n                }\r\n                if (isArray(source[key]) && !isArray(target[key])) {\r\n                    target[key] = [];\r\n                }\r\n                _mixin(target[key], source[key], deep, safe);\r\n            } else if (source[key] !== undefined) {\r\n                target[key] = source[key]\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function _parseMixinArgs(args) {\r\n        var params = slice.call(arguments, 0),\r\n            target = params.shift(),\r\n            deep = false;\r\n        if (isBoolean(params[params.length - 1])) {\r\n            deep = params.pop();\r\n        }\r\n\r\n        return {\r\n            target: target,\r\n            sources: params,\r\n            deep: deep\r\n        };\r\n    }\r\n\r\n    function mixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, false);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    function removeItem(items, item) {\r\n        if (isArray(items)) {\r\n            var idx = items.indexOf(item);\r\n            if (idx != -1) {\r\n                items.splice(idx, 1);\r\n            }\r\n        } else if (isPlainObject(items)) {\r\n            for (var key in items) {\r\n                if (items[key] == item) {\r\n                    delete items[key];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    function result(obj, path, fallback) {\r\n        if (!isArray(path)) {\r\n            path = [path]\r\n        };\r\n        var length = path.length;\r\n        if (!length) {\r\n          return isFunction(fallback) ? fallback.call(obj) : fallback;\r\n        }\r\n        for (var i = 0; i < length; i++) {\r\n          var prop = obj == null ? void 0 : obj[path[i]];\r\n          if (prop === void 0) {\r\n            prop = fallback;\r\n            i = length; // Ensure we don't continue iterating.\r\n          }\r\n          obj = isFunction(prop) ? prop.call(obj) : prop;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    function safeMixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, true);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    // Retrieve the values of an object's properties.\r\n    function values(obj) {\r\n        var keys = _.keys(obj);\r\n        var length = keys.length;\r\n        var values = Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            values[i] = obj[keys[i]];\r\n        }\r\n        return values;\r\n    }\r\n\r\n\r\n    \r\n    function clone( /*anything*/ src,checkCloneMethod) {\r\n        var copy;\r\n        if (src === undefined || src === null) {\r\n            copy = src;\r\n        } else if (checkCloneMethod && src.clone) {\r\n            copy = src.clone();\r\n        } else if (isArray(src)) {\r\n            copy = [];\r\n            for (var i = 0; i < src.length; i++) {\r\n                copy.push(clone(src[i]));\r\n            }\r\n        } else if (isPlainObject(src)) {\r\n            copy = {};\r\n            for (var key in src) {\r\n                copy[key] = clone(src[key]);\r\n            }\r\n        } else {\r\n            copy = src;\r\n        }\r\n\r\n        return copy;\r\n\r\n    }\r\n\r\n    return {\r\n        allKeys: allKeys,\r\n\r\n        clone: clone,\r\n\r\n        defaults : createAssigner(allKeys, true),\r\n\r\n        has: has,\r\n\r\n        isEqual: isEqual,\r\n\r\n        isMatch: isMatch,\r\n\r\n        keys: keys,\r\n\r\n        mixin: mixin,\r\n\r\n        removeItem: removeItem,\r\n\r\n        result : result,\r\n        \r\n        safeMixin: safeMixin,\r\n\r\n        values: values\r\n    };\r\n\r\n});"]}